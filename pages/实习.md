- ## 面试前准备
	- 检查耳机电量
	- 检查麦克风
	- 录屏
	- 把反问内容放到一边
		- 部门主要业务和技术栈? 语言?
		- 之后还会有几面? 整个流程大概多久?
-
-
- ## 简历投递 - 大厂
  collapsed:: true
	- 字节
		- [应聘记录 (bytedance.com)](https://jobs.bytedance.com/experienced/position/application)
			- [点直播传输优化实习生-视频架构 - 字节跳动 (bytedance.com)](https://jobs.bytedance.com/experienced/position/7205031835402946871/detail)
				- 2、熟悉UDP/TCP/HTTP等协议；
				- 3、熟悉常见的拥塞控制算法；
		- 内推码
			- A7RKASY
		- 校招技术群
			- 761261886
		- 宣讲会
		  collapsed:: true
			- 一面
			- 二面
				- 技术实力和真正解决问题的能力
				- 是否能主动发现新问题, 遇到挑战时又是怎么解决的
			- 三面
				- 更关注事情背后的个人能力
				- 开放性题目
				- 前端
					- ![image.png](../assets/image_1711006673450_0.png){:width 400,:height 800}
				- 后端
					- ![image.png](../assets/image_1711006776190_0.png){:width 400, :height 230}
				- 客户端
					- ![image.png](../assets/image_1711006888397_0.png){:width 400,:height 800}
				- 算法
					- ![image.png](../assets/image_1711006929443_0.png){:width 400,:height 800}
					-
	- 美团
		- [个人中心 | 美团招聘 (meituan.com)](https://zhaopin.meituan.com/web/personalCenter/deliveryRecord?staffSsoId=2320107)
		  collapsed:: true
			- [职位详情 | 美团招聘 (meituan.com)](https://zhaopin.meituan.com/web/position/detail?jobUnionId=2309697144&jobShareType=1&highlightType=campus&staffSsoId=2320107)
				- 岗位职责
					- 1.协助完成音视频相关领域的研究工作，包括但不限于：~~音频3A算法~~、==智能编码、码率自适应、拥塞控制、图像增强、Jitterbuffer算法等；==
					- 2.根据多个业务场景（实时音视频、直播、点播等）需求，进行算法开发和工程落地实现；
					- 3.参与音视频核心指标的优化，包括清晰度、延迟、卡顿、秒开等。
				- 任职要求
					- 1.计算机、电子信息或相关专业，本科及以上学历；
					- 2.具备扎实的理论基础和工程能力，==熟悉H.264、H.265、H.266== 以及其它视频编码标准的实现；
					- 3.思维敏捷，学习动手能力强，有技术热情；
					- 4.优秀的分析和解决问题的能力，项目推动力和团队协作能力。
				- 具备以下经验者优先：
					- 1.国际一流会议或期刊上发表过学术论文；
					- 2.熟悉音视频领域常用开源组件，比如==webrtc、ffmpeg、ijkplayer、srs==等；
					- 3.熟悉音频3A算法经验者；
					- 4.开源社区贡献者或成员。
		- 直播回放
		  collapsed:: true
			- [招4000人，美团2024年春季校园招聘2月26日全球启动 (qq.com)](https://mp.weixin.qq.com/s/AgtAEk-n4kzHWFwyC1mNHw)
	- 淘天
		- [淘天集团招聘官网 (taotian.com)](https://talent.taotian.com/personal/campus-application?lang=zh)
			- 面向RTC的音视频传输算法优化，包括但不限于带宽预测、拥塞控制、多码率自适应、音视频弱网对抗等算法；
	- 腾讯
		- [应聘进度 | 腾讯校招 (qq.com)](https://join.qq.com/progress.html)
			- 或熟悉HEVC/AVS2等视频编码标准，有VVC或者AVS3标准研究经验，具有扎实的图像、视频处理基础者优先。
	- 快手
		- [快手校招 - 快手校招-投递记录 (kuaishou.cn)](https://campus.kuaishou.cn/recruit/campus/e/#/campus/my-apply)
	- 小红书
		- [投递记录 (xiaohongshu.com)](https://job.xiaohongshu.com/record/intern)
		-
	- 小米
		- [应聘记录 - 小米实习生招聘 (mioffice.cn)](https://xiaomi.jobs.f.mioffice.cn/internship/position/application)
			- [多媒体编码标准工程师实习生 - 小米实习生招聘 (mioffice.cn)](https://xiaomi.jobs.f.mioffice.cn/internship/position/7342812731219214445/detail)
			- [Linux多媒体开发工程师-实习 - 小米实习生招聘 (mioffice.cn)](https://xiaomi.jobs.f.mioffice.cn/internship/position/7341363155464306797/detail)
			  collapsed:: true
				- 任职要求：
				  1、本科及以上学历，具备扎实的c/c++，熟悉基本的数据结构及算法；
				  2、熟悉VLC,、FFmpeg、Stagefright、GStreamer中一种或多种多媒体框架；
				  3、熟悉音视频容器（flv，mkv，mp4，wmv，avi,rm/rmvb等）的封装格式；
				  4、熟悉HLS 、Http、HttpLive、rtp/rtsp中一种以上流媒体开发；
				  5、熟悉Dolby Vision、Dolby Audio、DTS Audio、CTS、GTS等认证相关工作优先；
				  6、有强烈的责任感和良好的团队合作精神，积极主动，创新意识强。
	-
	- [牛客网 - 找工作神器|笔试题库|面试经验|实习招聘内推，求职就业一站解决_牛客网 (nowcoder.com)](https://www.nowcoder.com/)
	- [实习僧|大学生实习|校招求职|校园招聘 (shixiseng.com)](https://www.shixiseng.com/)
	- [专注于C/C++领域-C/C++招聘网站 (0voice.com)](https://job.0voice.com/)
	-
	-
-
- ---
-
- ## 面经
	- [面经实战 (notion.site)](https://funny-tarp-f04.notion.site/8b34acd5f8be4ed79eb640afc1aa56ec)
	-
	- 腾讯 3.27 一面
	  collapsed:: true
		- 细节
			- 眼神飘忽
			- 太过啰嗦; 记得要先说重点!
		- 给你两分钟时间, 做一下自我介绍
			- 适当增长
		- 项目
		  collapsed:: true
			- GC
				- 队伍有多少人? 你大概负责哪部分?
				  collapsed:: true
					- 说的太啰嗦了
					- 整个项目分为3个部分: tile切分策略, 视点预测, 以及tile下载决策算法. 我主要负责后面两个部分.
				- 视点预测具体怎么做的? 做了哪些trick提分?
					- 使用了线性回归模型, 根据过去20个视点位置预测未来的视点位置
					- ((66076e7f-814c-424e-ba1d-7fa134547d90))
				- 比赛的评价指标?
					- ((66077229-bb27-4bf6-a6b2-13202c1403b8))
			- 中移
			  collapsed:: true
				- 是用CNN做的吗? 就是说这个模是怎么建的?
				  collapsed:: true
					- 基于心理学公式建模, 分别是 "韦伯-费希纳定律" 和 "IQX假设"
					- 对于与QoE正相关的指标, 我们基于 "韦伯-费希纳定律" 进行对数建模
						- 如视频比特率 (可以使用下行总字节数这一网络指标来衡量)
					- 对于与QoE负相关的指标, 我们基于 "IQX假设" 进行指数建模
						- 如卡顿, 时延, 丢包
		- 八股
		  collapsed:: true
			- 计网
			  collapsed:: true
				- 在浏览器中输入一个网址之后, 它背后的运行过程?
				- TCP和UDP的区别? 我们现在的视频会议是基于哪一种?
				- ==你了解IPV4和IPV6吗?==
				- 面试官提醒: 每个问题的回答控制在一分钟左右
			- 算法
				- 我们公司现在有一批产品的图片需要处理, 这些图片中可能有一些是不符合公司标准的, 比如有一些logo, 有一些水印, 有一些损坏, 你的任务是设计一个自动检测系统, 来去除这些不符合标准的图像. 你可以从算法的角度讲一下这个题吗?
				  collapsed:: true
					- poe
						- 准备模型输入
							- 1. 图像预处理：首先，对原始图像进行预处理，包括统一图像大小, 归一化之类，以便后续算法能够更好地处理图像。
							- 2. 特征提取：使用计算机视觉技术，提取图像中的特征。这些特征可以包括颜色直方图、纹理特征、边缘信息等。特征提取的目的是将图像转换为计算机可以理解和处理的数值表示形式。
						- 准备模型输出
							- 3. 样本标注：准备一批已经标注的图像样本，其中包含了符合公司标准和不符合公司标准的图像。标注可以通过人工标记或者半自动标记的方式进行。
						- 模型训练
							- 4. 模型训练：使用已标注的图像样本，训练一个分类模型，例如卷积神经网络（CNN）。CNN在图像处理任务中表现良好，可以学习到图像的特征表示和分类决策规则。
						- 模型测试
							- 5. 模型评估：使用测试集评估训练好的模型的性能。评估指标可以包括准确率、召回率、精确率等，用于衡量模型对不符合标准图像的检测能力。
						- 模型投入使用
							- 6. 不符合标准图像检测：将待处理的图像输入训练好的模型，通过模型进行预测，判断图像是否符合标准。如果模型预测为不符合标准，可以进行相应的处理操作，如去除logo、水印或修复损坏部分。
						- 模型迭代优化
							- 7. 后续优化：根据实际应用情况，对系统进行优化和改进。可以考虑使用更复杂的模型结构、增加训练数据量、引入数据增强技术等，以提高系统的准确性和鲁棒性。
				- 介绍一下CNN有哪些网络结构
				  id:: 6604cfd6-0a99-4a2a-93d4-95c47dbb0cb8
				  collapsed:: true
					- (conv + ReLU + pooling) + (conv + ReLU + pooling) + (fc + ReLU) + (fc + softmax)
					  collapsed:: true
						- ```python
						  class LeNet(Module):
						  	def __init__(self, numChannels, classes):
						  		# call the parent constructor
						  		super(LeNet, self).__init__()
						  		
						          # initialize first set of CONV => RELU => POOL layers
						  		self.conv1 = Conv2d(in_channels=numChannels, out_channels=20,
						  			kernel_size=(5, 5))
						  		self.relu1 = ReLU()
						  		self.maxpool1 = MaxPool2d(kernel_size=(2, 2), stride=(2, 2))
						  		
						          # initialize second set of CONV => RELU => POOL layers
						  		self.conv2 = Conv2d(in_channels=20, out_channels=50,
						  			kernel_size=(5, 5))
						  		self.relu2 = ReLU()
						  		self.maxpool2 = MaxPool2d(kernel_size=(2, 2), stride=(2, 2))
						  		
						          # initialize first (and only) set of FC => RELU layers
						  		self.fc1 = Linear(in_features=800, out_features=500)
						  		self.relu3 = ReLU()
						  		
						          # initialize our softmax classifier
						  		self.fc2 = Linear(in_features=500, out_features=classes)
						  		self.logSoftmax = LogSoftmax(dim=1)
						  ```
					- [CNN（卷积神经网络）架构 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/46851548)
					- ![image.png](../assets/image_1711627569521_0.png){:width 400,:height 800}
				- 介绍一下 [[LSTM]]; 它是如何实现长短时记忆的?
				  id:: 6604d00e-8cd2-4448-8caa-d2cfc11d0c3e
				  collapsed:: true
					- 核心是 cell state 和 三个门控机制
					- 遗忘门通过 "上一时刻的隐藏状态" 和 "当前时刻的输入", 决定cell state要遗忘什么
					- 输入门通过 "上一时刻的隐藏状态" 和 "当前时刻的输入", 决定要向cell state中输入什么
					- 输入门通过 "上一的隐藏状态" 和 "当前时刻的输入", 决定要从cell state中输出什么 (这里的输出就是 "当前时刻的隐藏状态")
					-
				- 在做神经网络的时候, 可以将全部的初始参数设置为0吗?
				  id:: 6604d022-e344-45c1-9fbf-2171673b7cfe
				  collapsed:: true
					- **对称性问题**：如果在网络中的所有权重都开始于0，那么在反向传播的过程中，每层的所有神经元将会以相同的方式更新, 都只会学习到一个相同的特征. 我们希望的是模型学习到的特征尽可能多样化
					- 常用的参数初始化方法
						- 随机初始化; 从均匀分布或者正态分布中采样
						- Xavier (读作ZV2)
						  collapsed:: true
							- ![image.png](../assets/image_1711629621816_0.png){:width 400,:height 800}
						- He
						- 其它
						  collapsed:: true
							- LeCun (乐酷)
							- ![image.png](../assets/image_1711630243937_0.png){:width 400,:height 800}
		- 算法
		  collapsed:: true
			- 寻找一个list中, 和给定值最接近的值
			- syw: 判断一个list中是否存在一个子序列, 它的和等于给定值
	- 腾讯 3.28 二面
	  collapsed:: true
		- 模型评估的方法
		  id:: 66056cbe-e40e-45de-af22-4ce6a8b04612
		  collapsed:: true
			- 留出法（Hold-out）
			  collapsed:: true
				- **留出法是机器学习中最常见的评估方法之一，它会从训练数据中保留出验证样本集，这部分数据不用于训练，而用于模型评估**。
			- 交叉验证法（Cross Validation）
			  collapsed:: true
				- **留出法的数据划分，可能会带来偏差**。在机器学习中，另外一种比较常见的评估方法是交叉验证法—— K折交叉验证对K个不同分组训练的结果进行平均来减少方差。因此模型的性能对数据的划分就不那么敏感，对数据的使用也会更充分，模型评估结果更加稳定，可以很好地避免上述问题。
			- 自助法（Bootstrap）
			  collapsed:: true
				- 对于大小为n的样本集合，进行n次有放回的随机抽样，得到大小为n的训练集，n次采样过程中，有的样本没有被抽出过，将这些没被抽出的样本作为验证集，进行模型验证，这就是自助法的验证过程。
				-
		- 为什么transformer可以并行化
		- 模型部署的过程
			-
	-
	- [美团测开一面3.28_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/87f1c5e1121c4bae8c57750976004426)
	  collapsed:: true
		- ==事务的隔离性是什么?==
		-
	- [美团前端/移动端一面凉经_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/602972611047354368?sourceSSR=dynamic)
	- [美团到店一面凉经_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/603218437531336704)
	-
	- [3.20美团音视频暑期一面面经_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/43ae1b706b2c4f1dadb9ab4f8772cf97?sourceSSR=dynamic)
	  collapsed:: true
		- 介绍一下项目是干嘛的，问这个项目里面你印象最深的问题是什么，怎么解决的。
		- C++
			- C++多线程，怎么用的
			- 智能指针用过哪些
			- 智能锁，项目里用到了吗
			- 面向对象三大特性
			- 讲讲多态
			- 虚函数，原理
			- 静态成员函数可以是虚函数吗
			- 内联函数可以是虚函数吗
			- 纯虚函数和抽象类
			- vector和deque的区别，线程安全吗
			- new和malloc区别
		- 计网
		  collapsed:: true
			- ~~5层7层模型~~
		- 系统
		  collapsed:: true
			- ((66077df7-e19c-4723-a8d2-99b4d12afcf1))
		- 知道GOP吗
		- rtsp服务器流程
	- [美团音视频暑期二面_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/655faeb8a7c043d6881d99884b1b8ed3?sourceSSR=search)
	  collapsed:: true
		- 然后问了问raft协议是怎么实现的
		- 闲聊ing，中途提到我这个笔试的时候有切屏的动作，我说我在找板子。。。他说我们不太看重这个，要是别的公司可能就直接给你挂了，我当时汗流浃背，疯狂道歉说下次注意。
		- 一道数学题，给一个圆半径是1，一个可以随机生成一个数的函数，要求你在这个圆上打孔，打无限次之后这个孔要均匀的分散在圆上，问怎么利用这个随机函数。
		- 问一下有什么印象让你深刻的点，不限于项目，生活工作学习都行。
	- [美团一二面经分享_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/a392ea54aea448ddad7957745d184d6c?sourceSSR=users)
	  collapsed:: true
		- 一面
		  collapsed:: true
			- 一、项目
			  collapsed:: true
				- 介绍项目，介绍自己做的板块，有什么难点
				- 你幂等的token是随机生成的吗
				- 你用了list和zset，你说说他们的使用场景
				- KafkaSream的工作原理的什么？
				- 为什么使用kafka，为什么使用KafkaStream，Java不是也有流式处理吗？
				- 看你写了sql优化，你说说是怎么优化的吧
				- 这里开背八股，着重说了索引
				- 你查看过sql执行计划吗？
				- 你优化后，响应时间有什么突破吗？
				- 有没有考虑接口请求慢是由于代码逻辑的问题，而不是sql？
			- 二、八股（只问简历上有的，我哭死）
			  collapsed:: true
				- redis有那些数据结构
				- 介绍AQS
				- Mysql事务四大特性
				- Redis持久化机制
				- 线程池有哪些种类（忘了）
				- 说说线程池的核心原理
				- 线程池的阻塞队列有哪些，说说工作原理
			- 三、算法
				- 数组中的第K大数字
				- 重排链表
			- 四、开放性问题
				- 部门是搞美团直播的，问我对直播的看法
			- 五、反问
		- 二面
		  collapsed:: true
			- 项目：
				- 垂直分表怎么实现的
				- 这些功能是你自己想的吗，还是参考的
				- 接口幂等实现
				- 这些功能是你自己想的吗，还是参考的
				- 线程池参数怎么设置的
				- 背了八股，最后问为什么是 cpu核数*2+1，在那里磕磕巴巴，面试官说不会就直接说就行
			- 后面闲聊穿插八股
				- trivial
				  collapsed:: true
					- 数据结构和操作系统考了多少分，排名多少
					- Spring依赖注入有哪些方式
					- 你一般怎么实现依赖注入
					- @component和@service有啥区别
					- 看过java源码吗
					- hashmap重写equals方法的时候，为什么要重写hashcode方法
					- 那你说说怎么计算出索引下标的
				- 现在openAI这么火，你有在项目中使用过大模型之类的吗
			- 算法：反转链表
	-
	- [快手音视频sdk一面面经_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/342530760b864b29a4bd0822e7fe8f5a?sourceSSR=users)
	  collapsed:: true
		- trivial
		  collapsed:: true
			- 楼主是菜鸡acmer，他看我直接打过比赛直接给我上了个hard，一看题是字符串匹配变种就人麻了。。。让他给换了一道题，又换了一个easy的，3分钟秒了，进入毕设拷打。
			- 楼主毕设是车辆多目标跟踪，他让我介绍目标跟踪，现在的流程是什么，什么原理，因为楼主只懂多目标跟踪于是就扯了一下思路，然后又问单目标跟踪，随便画框如何跟踪。。。又扯了一堆。
		- 两道智力题，
		  collapsed:: true
			- 一题是一个棋盘两个人分别落子，落子不能有任何重叠，落不了就输，提示了一下做出来了，
			- 二题经典两个瓶子一百楼，最坏多少次能试出来摔碎层数。
			- [智力题（程序员面试经典）_假如你有31张牌,每一张恰好可以遮盖上两个正方形。你能否用棋盘骨牌把这个棋-CSDN博客](https://blog.csdn.net/bigpudding24/article/details/44198989)
		- 之后随便问了一下IPB帧的知识，问我变速怎么的时候怎么利用这些帧缓解性能压力。
		  collapsed:: true
			- [LiveVideoStack » Easy Tech：什么是I帧、P帧和B帧？](https://livevideostack.cn/news/i-p-b-frames-idr-keyframes-differences-usecases/)
				- GOP
					- 连续的帧组成的图像组
				- I帧
					- 独立进行编解码, 不参考其它的帧, 也就是只会做帧内压缩
					- 每个 GOP 开头的第一个帧一定是I帧
				- P帧
					- 前向参考帧, 可以参考之前帧进行编解码
				- B帧
					- 双向参考帧, 可以参考之前或者之后的帧进行编解码
				- IDR帧
					- IDR帧就是 "立即解码刷新帧"
					- IDR帧会导致参考帧列表清空, 使错误不致传播
					- IDR帧是一种特殊的I帧; 位于GOP的开头, 这个GOP的帧不能参考其IDR帧之前的帧
					  collapsed:: true
						- IDR帧一定是I帧, 但I帧不一定是IDR帧
						- 对于IDR帧来说，在IDR帧之后的所有帧都不能引用任何IDR帧之前的帧的内容，与此相反，对于普通的I-帧来说，位于其之后的B-和P-帧可以引用位于普通I-帧之前的I-帧。
	- [快手暑期音视频二面_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/b3279c30567f4e168702bfa002447822?sourceSSR=dynamic)
	  collapsed:: true
		- 算法
			- 第一道题是求两个数相除的循环节，如果除得尽就没有，除不尽的话比如1/7就输出148257
			- 第二道题给一个链表，求第k大，要求O(1)的空间，O(nlogn)时间，写完刚好1h，直接下班。
	-
	- 美团 4.01 一面
	  collapsed:: true
		- 纯项目
			- 中移
				- 识别质差的原因
				- 最大的难点
					- 只使用机顶盒探针采集到的TCP传输层指标对QoE做建模, 所以需要把建模QoE的各种QoE metrics使用TCP传输层指标预测出来
			- 视频传输
				- WebRTC
					- WebRTC里是如何做码率自适应的? 比如网络不好的情况下是如何做调节的?
						- 说会发送RTCP数据, 里面有一些QoS指标的反馈, 比如时延, 丢包等
					- 那如果丢包了怎么办?
						- 说使用NACK和FEC两种机制
					- 那你能详细的说一下FEC的原理吗?
						- 不会了
					- 你们自己在做的时候有没有丢包恢复的经验?
						- 我能想到的只有重传
					- 重传是不是效率太低了? 有没有其他策略?
				- QUIC协议有没有了解过?
				- 基于UDP的没了解过的话, 那我们说一下基于TCP的吧; DASH的整体传输机制是什么?
					- segment
					- bitrate levels
					- MPD
					- 客户度请求和解析MPD, ABR算法选择请求哪个segment的哪种质量等级
					- 服务器处理请求返回数据
				- DASH的实时性可能不高? 针对这一点业界有什么解决方案?
				- 画质评价指标
					- PSNR的计算方式
					- PSNR的问题
						- 不接近人真实的视觉感受
					- 那你有了解一些其它指标吗? 比如更加贴合人真实感受的一些
				- 平时用什么语言开发比较多
					- ==以后遇到直接说C/C++用的多==
					- 硕士期间数据分析+深度学习, 所以python用的比较多
					- 之前是C/C++用的比较多
				- 视频切割是怎么做的? 是用python在后端做的吗?
					- 是直接调用的ffmpeg的接口
				- 那你对ffmpeg了解多吗? 对它的架构有了解吗? 比如它有哪些模块? 有看过它的原码吗?
				- 对于360°视频流传输来说, 现在最大的难点是什么?
				- 如果我头部突然运动的话, 会不会要求传输的数据量就会非常高? 就会胡就会卡? 针对这种情况你有没有什么办法?
					- 优先传输background
				- 能不能从编码的角度考虑这个问题?
					- 我关于编码能想到的就是每个tile编码出各种bitrate等级共客户端选择
					- 每个tile在传输之前都是独立编码好的, 传输的时候肯定不能实时编码
				- 在传输的时候, 有一个tile没传过来, 那有没有办法把它恢复出来?
					- 说实时编解码可能不可取; 帧内预测的时候也是一个宏块一个宏块去做
				- 这只是一个思路嘛, 还有很多别的思路 (估计是面试官一拍脑袋想的)
		- 反问
		  collapsed:: true
			- 技术栈, 语言
				- 直播客户端组
				- 直播的端栈架构, 包括采集, 编码, 传输, 效果
				- 传输基本都是WebRTC的
				- 目标是保证客户端视频播放的流畅性
				- 有推流有拉流, 要保证整个直播不会出现马赛克等问题
				- C++ > java
			- 我们是C++客户端的职位, 可能和你不是很相符
			- 音视频有很多岗位, 有直播, 点播, 客户端的有服务端的, 服务端有做转码的; 可以考虑一下之后的职业规划是什么
	- 快手 4.01 一面
	  collapsed:: true
		- 项目
		  collapsed:: true
			- GC
				- 详细介绍一下这个项目
					- 目标
					- 三部分
					- 预下载时长的动态调整算法
				- 有一个比较大的问题, 360°视频流传输, 相比于DASH之类的普通视频流传输, 是不是就是多了个视点预测之类的? 这一块diff这些年是有一些迭代有一些算法吗?
					- 这个问题当时没有听明白面试官在问什么
				- 现在视点预测一般怎么去做
					- 说了说短期预测用什么
					- 又说了说我论文在做长期预测
				- 点播的话, 是不是可以基于其他用户的行为辅助视点预测?
					- 是的, 这也是一种常用的辅助信息, 但有以下问题需要考虑:
						- 冷启动
						- 聚类
				- ==ABR这一块你们主要使用了什么样的算法?==
				- ==每个tile会有多个码率吗?==
				- 那么你在其它研究中对ABR有什么了解吗
					- 说了DASH的ABR策略
		- 算法
			- 从前序与中序遍历序列构造二叉树
		- 其他
			- 你对做的东西有什么预期吗?
				- 说项目比较偏传输
			- 面试官直接说, 你那个传输就是视点预测, 其实不涉及到传输; 然后问你其他和传输相关的有没有什么项目
				- 没有了; 就了解过一些WebRTC和DASH的知识
		-
	-
	- 淘天 4.08 一面
	  collapsed:: true
		- 部门介绍
			- 淘天集团业务技术部的音视频团队 (100多人)
			- 采集, 增强, 美颜, 推拉流传输, 播放器, 全链路的音视频技术栈
			- 传输
				- 基于WebRTC的推拉流系统的实现, 主要是淘宝==直播==还有==短视频==
				- 底层传输算法
					- 带宽探测
					- FEC
					- atb?
				- 直播切流 (比如从1080p切到720p)
				- 短视频 (和预下载相关)
		- 自我介绍
		- 实验室情况
		  collapsed:: true
			- 导师主要的研究方向
			  collapsed:: true
				- 网络与人工智能交叉领域
				- 智慧交通 (让网络也能自动驾驶)
				- 手势识别
				- 边缘计算
			- 流媒体组之前发过的有关传输的论文
			  collapsed:: true
				- 低延迟直播场景中, ABR的更细粒度切换
				- [[@Vabis: Video Adaptation Bitrate System for Time-Critical Live Streaming]]
				- [[@Timely and Accurate Bitrate Switching in HTTP Adaptive Streaming With Date-Driven I-Frame Prediction]]
		- 科研经历
		  collapsed:: true
			- GC
				- 比赛用的系统, 具体介绍一下; 比如怎么对网络做的仿真, 文件是怎么存储的, 服务端和客户端大概是什么样子
				- 它有模拟什么具体的传输协议吗? 网络具体是怎么模拟的呢?
				  collapsed:: true
					- network trace (读作trees)
				- 难点
				  collapsed:: true
					- 预下载时长的动态调整机制
				- 那这个预下载时长的确定, 现有的研究里面没有涉及到吗?
				  collapsed:: true
					- 说到了现有的360ABR的两个由于视点预测误差导致的难点: 视点预测误差建模 和 低质量tile替换策略; 解释说预下载时长动态调整这个比较偏应用, 目前没有看到相关的研究
				- 那你们这个预下载时长动态调整算法, 输入是什么?
				  collapsed:: true
					- 视点信息, 网络带宽的预测, 以及下一个视频块中各个tiles的体积大小; 因为只有这样才能计算出预下载策略的下载时长
				- 网络带宽怎么预测的?
				  collapsed:: true
					- 线性回归模型; 因为不需要长期预测
				- 你们对ABR这部分有设计吗?
				  collapsed:: true
					- 将DASH这种普通视频流传输系统中的ABR策略, 适配到360°视频流传输的场景上
						- 主要策略
							- 基于吞吐量
						- 次要策略
							- 缓冲区不足
							- 替换策略
				- 听下来类似于MPC (模型预测控制) ?
			- STAR-VP
			  collapsed:: true
				- 模型规模?
					- 模型体积 30MB 左右
					- batch_size调成64的话, 显存占用为 38G 左右
				- 模型收敛需要训练多久?
					- 50个epoch (一炮可), 大概一个小时左右
		- 项目经历
		  collapsed:: true
			- 中移
		- 专业技能
		  collapsed:: true
			- C++
				- WebRTC, QUIC, TCP
			- DASH, WebRTC, H.264
				- 整个系统怎么传输? 怎么分片, 分片之后怎么做, cde上怎么运作
				- WebRTC
		- 反问
		  collapsed:: true
			- 对WebRTC系统的理解要再深刻一些
	- 淘天 4.10 二面
	  collapsed:: true
		- 部门介绍
			- 淘天集团音视频技术团队
			- 音视频算法, 编码, 处理增强, 传输, 质量评价, 音频相关算法
			- 视频播放, 推流, 传输
			- 淘宝直播, 淘宝短视频
		- 八股
			- 操作系统
				- 怎么提升逻辑地址到物理地址的转换效率?
				  collapsed:: true
					- 为了提高系统的效率，通常会使用一些硬件机制来辅助逻辑地址到物理地址的转换过程，如TLB（Translation Lookaside Buffer）等。
			- 计算机网络
				- 怎么提高三次握手建立连接的效率?
				- TCP包头, UDP包头
		- 项目
			- 基于tile的360°视频流传输, 其实是一种bitrate level的所有tiles对应一个视频流, 而不是每个tile的每种bitrate等级对应一个视频流
		- 反问
			- 直播基于webrtc, 短视频基于http或者quic
			- 直播推流, 短视频选流, 自适应加载
			- WebRTC中带宽探测, 拥塞控制的算法 (GCC, BBR, PCC) 具体是怎么做的
			- QUIC协议新的动向
	-
	- [淘天hr面_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/611675139712770048?sourceSSR=dynamic)
	  collapsed:: true
		- **1.大学学校和专业的选择思考逻辑**
		- **2.计算机专业吸引我的点是什么**
		- **3.擅长人际关系处理吗**
		- **4.为什么想要来杭州**
		- **5.没准备继续读研吗**
		- **6.现在成绩什么位置**
		- **7.acm是什么样的比赛（和我经历硬相关了）**
		- **8.为什么这么执着于参加竞赛（和我经历硬相关了）**
		- **9.为什么不选择算法工程师而是后端（和我经历硬相关了）**
		- **10.为什么这么排斥读研**
		- **11.本科生和研究生比的优势在哪**
		- **12.自己应聘这个岗位的优势是什么**
		- **13.自己相对来说要进一步提升的点是什么**
	- [淘天-暑期实习-业务技术后端-面经_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/611696355077103616?sourceSSR=post)
	  collapsed:: true
		- 自我介绍
		- 为什么不继续留在上家公司实习？
		- 对部门业务有什么了解？如何胜任这份工作？
		- 学习或实习中比较有挑战性的case？
		- 过去二十几年里对你影响比较大的人或事？
		- 手里有什么offer？
		- 提前了解一下部门业务，一方面HR面可能会问到你对公司、部门业务的了解，另一方面如果你投递的是与自身经历匹配度比较高的部门，可能也是一种无形的优势。
	-
	- [快手 音视频_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/532872143856578560?sourceSSR=search)
	  collapsed:: true
		- ## 一面
			- C++
				- unique_ptr，shared_ptr，weak_ptr
				- 多态实现，虚函数虚表，重载，模板实现原理
				- lambda 值捕获，引用捕获的实现原理，如果lambda 函数参数是 unique_ptr，然后传一个右值进来，是值捕获还是引用捕获
			- OS
				- 锁：spin lock，mutex 实现原理
				- cas 改的那个值是放在哪？
				- page cache 原理
				- malloc 实现原理，然后怎么优化，讲了下tcmalloc
			- 网络
				- 四次挥手，timewait为什么要等2msl，能不能合并第二和第三次挥手。
				- 五种 IO 模型，同步阻塞，同步非阻塞，io多路复用，信号驱动io，异步io
				- select 和 epoll，epoll 相对 select 的优点
			- 项目
				- 冷存项目中遇到的最大困难是什么，挑一个修bug的故事讲讲
				- ceph 的一致性协议，paxos，没怎么看过 paxos，讲了讲 raft 的原理
				- 挑些你认为 ceph 写的好的代码讲讲。
			- 其他
				- 怎么去查程序的性能瓶颈：perf，转火焰图，然后问了下对于一些定期执行的操作，这种perf可能采样不到，怎么去定位和解决
			- 算法：
				- 两个有序数组找中位数 --> 三个有序数组找中位数
		- ## 二面 8/11
		  
		  运气不错，面到了一个曾经做过数据库的面试官。聊了下项目
		  
		  天池比赛
		  
		  实验室存储项目
		  
		  算法
		- 接雨水
		- ## 三面 8/28
		  
		  问了20分钟 cpp，cpp mutex的实现，malloc，虚函数序表，多态，设计模式之类的。
	-
	- [音视频开发大厂面试题（快手、百度、字节）_音视频面试题-CSDN博客](https://blog.csdn.net/m0_60259116/article/details/124851205)
	-
-
- ## 自我介绍与反问
  collapsed:: true
	- ### 参考资料
	  collapsed:: true
		- [【面试千问】技术岗面试的细节问题_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/507493739066097664?sourceSSR=users)
	- ### 自我介绍
	  collapsed:: true
		- 面试官您好，我叫高宝琪, 是
			- 2025 届
			- 计算机专业
			- 硕士研究生，
		- 学历
			- 本科就读于 北京化工大学 计算机科学与技术 专业，
			- 硕士就读于 北京邮电大学 计算机科学与技术 专业。
		- 科研与项目
			- 我硕士期间的研究方向是360°视频流传输.
			- 我在今年参加了 字节跳动 组织的 ACM MMSys' 24 Grand Challenge, 这是一个与360°视频点播流传输相关的挑战赛, 并且获得了第一名的成绩.
				- 我设计了一个 "预下载时长的动态调整机制", 它可以使算法在各种情况下, 都优先保证画面质量, 尽可能降低带宽和存储等开销
			- 之前还负责过北邮和中国移动研究院那边的联合创新项目, 主要是对视频播放业务的用户体验质量进行建模。
		- 未来计划
			- 未来的打算是做一些音视频相关算法或者开发方向的工作。
	- ### 反问环节
	  collapsed:: true
		- 后面还需要几面？
		- 整个流程到offer 发放大概持续多久？（根据面试官回答反推本次面试的结果）
		- 部门/组的技术栈 or 业务
		- 转正率（表明自己转正心态）
		- 实习时长（可以主动提及自己能长时间实习）
-
- ## 项目
  collapsed:: true
	- ### 360°视频点播流传输挑战赛 (ACM MMSys '24 GC) | 第一名
	  collapsed:: true
		- 目标
		  collapsed:: true
			- ==在字节开源的360°视频点播流传输评估平台上==, 开发自己的方法, 最终目标是使用尽可能少的系统资源提供尽可能高的用户观看质量。
		- HR面
		  collapsed:: true
			- 一个主要的难点就在于: 360°视频流传输领域, 很难找到ABR算法的参考
				- 像我这次去意大利参会的时候, 有一篇最新的论文, 就是吧DASH中针对普通视频的基于缓冲区的BOLA算法适配到了360°视频中, 起名叫BOLA360; 而我们在这次比赛中相当于是将DASH中的另一种ABR算法, 就是基于吞吐量的方法, 适配到了360°视频中. 这个还是很让我感到兴奋的
			- 也就是说, 360°视频领域找不到合适的参考, 但普通视频的ABR策略已经很成熟了, 我们就想能不能参考普通视频的ABR策略, 向360°视频做适配
			- 具体来说, 我们先调研DASH中有哪些ABR算法, 它们的原理是什么, 哪些适合用于360°视频流传输, 360°视频和普通视频的差异点在哪, 需要做哪些适配. 把这些问题搞清楚了, 最终实现就可以了
			- 最终我们也是取得了第一名的名次
		- 基础方法
		  collapsed:: true
			- tile切分
			- 视点预测
			- ABR算法
		- ==你们采取的ABR策略是什么?==
		  collapsed:: true
			- 主要策略 (0 + 3)
				- ((660bdf6b-5311-4228-8e22-14d417469dd5))
				  collapsed:: true
					- (为什么不用基于缓冲区的方法?)
						- 为了保证视点预测的精度, 我们只做短期视点预测, 因此只建立短缓冲区
						- 短缓冲区的话, 基于缓冲区的ABR策略性能很差, 所以我们选择基于吞吐量的方法
					- 计算两个带宽
						- 带宽1: 根据历史带宽trace预测出的带宽, 乘0.9的安全系数
						- 带宽2: 使得分取得极大值的极值点对应的带宽 (极值点是 38Mbps)
						- 决策带宽 = min(带宽1, 带宽2)
					- 根据决策带宽进行分档 (直接举例说明会更加清晰)
						- 3种bitrate level (1Mbps, 2Mbps, 4Mbps)
						- 用分档之后富余的带宽, 优先将靠近视点的区域换为高bitrate level
					- ~~background视频流 (200kbps)~~
			- 次要策略 ([[#blue]]==可不说; 替换策略的细节那里比较难应付==)
				- ((660bdf7f-a624-4555-9dad-c159cb7ee9b7))
				  collapsed:: true
					- 根据历史带宽trace预测出的带宽 * 0.7
					- 求出的保守带宽 * 缓冲区存量, 得到缓冲区耗尽之前可供下载的数据量上限
					- 然后根据这个数据量调整预下载决策
				- ((660bdfc0-9aaa-4c46-b9ee-6ab503d823c4))
				  collapsed:: true
					- 初次下载一个chunk时, 需下载的tiles较多, 所以质量可能较差, 所以在预下载下一chunk之间的那段时间, 可以对当前chunk的低质量tiles进行替换
		- ==360°视频的ABR算法和普通视频的区别==
		  collapsed:: true
			- 要考虑的东西更多 (==根源就是多了视点预测==)
				- 360°视频相比于普通视频, 除了考虑网络情况, 还要考虑视点预测
				- 所以除了考虑带宽预测的误差, 还要考虑视点预测的误差
					- 建模误差分布
						- 空间: 高斯分布
						- 时间: 方差越来越大
						- 运动: 考虑上视点运动 (视点运动的方向margin大; 反方向margin小)
				- 长期视点预测 + 缓冲区替换策略
			- QoE优化目标 (这个点比较小)
				- 普通视频
					- 视觉质量
						- bitrate level
						- 时间差异
				- 360°视频
					- 视觉质量
						- 视口内tiles的bitrate level
						- 时间差异
						- 空间差异
		- 预下载时长的动态调整机制
		  id:: 66076e7f-814c-424e-ba1d-7fa134547d90
		  collapsed:: true
			- 解释预下载
				- 预下载就是提前多久对下一视频块进行下载
			- 解释为什么需要动态调整
				- 短会?
				- 长会?
				- 最理想是?
			- 具体如何实现动态调整的?
				- 每做完一次tile下载决策之后, 都会去对预下载时长进行调整
				- 首先初始化预下载时长为最小值, 如0.1s
				- 预测0.1s之后的视点位置, 假设这就是用户开始看下一视频块的视点位置, 根据这个视点位置去制定下一个视频块的预下载决策
				- 如果这个决策的总传输延迟大于预下载时长, 说明我们当前的预下载时长太短了, 我们把它增大一个步长, 比如0.11s, 继续循环上面的操作
				- 直到预下载时长刚好覆盖预下载决策的传输延迟
		- 画质评估算法
		  id:: 66077229-bb27-4bf6-a6b2-13202c1403b8
		  collapsed:: true
			- [图像质量评估各项指标（一）_有参考图像质量评价指标-CSDN博客](https://blog.csdn.net/qq_27825451/article/details/102954096)
				- 全参考
					- [图像质量评价指标之 PSNR 和 SSIM - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/50757421)
						- PSNR
						  collapsed:: true
							- PSNR (Peak Signal-to-Noise Ratio) 峰值信噪比
							- PSNR就是 $\frac{1}{MSE}$ 乘了一个常数
							  collapsed:: true
								- ![image.png](../assets/image_1711594611473_0.png){:width 400,:height 800}
							- 前面的那个 $10log_{10}$ 只是为了将单位转化为dB
						- SSIM
						  collapsed:: true
							- SSIM (Structural SIMilarity) 结构相似性
							- 基于两图的：亮度 (luminance)、对比度 (contrast) 和结构 (structure) 的相似性进行计算
							- 亮度就是均值, 对比度就是方差, 结构与协方差相关; 最后三项相乘, 每一项有一个指数系数
								- ![image.png](../assets/image_1711763910649_0.png){:width 400,:height 800}
							- 取值范围为0-1, 越大越好
							- 与PSNR相比，SSIM更加注重人眼感知到的结构和对比度的变化，更能反映图像的真实质量。
				- 半参考
					- 所参考的信息是从图像中提取出来的特征，所以它必须要先提取待评图像和理想图像的部分特征信息，通过比较提取出的部分信息对待评图像进行质量评估。
				- 无参考
					- **均值** (反映亮度)
						- 均值是指图像像素的平均值，它反映了图像的平均亮度，==平均亮度越大，图像质量越好==，设待评价图像为F，大小为M  N，其均值计算公式为：
					- **标准差** (反映对比度)
						- 标准差是指图像像素灰度值相对于均值的离散程度。如果标准差越大，表明图像中灰度级分别越分散，图像质量也就越好，其计算公式为：
					- 熵
						- 图像中的信息熵越大，说明图像包含的信息越多。
		- ~~之前整理的太过详细的内容~~
		  collapsed:: true
			- 难点
			  collapsed:: true
				- 如何设定视点预测时间窗口
					- 即对多久之后的视点位置进行预测并根据预测结果选择需要传输的tiles。
					- 短
						- VP预测更准确
						- 可能来不及下载完
					- 长
						- VP预测不准确
							- 带宽的浪费 / 用户视口中出现空区
					- 最优: 刚刚够下载完决策中的tiles
			- 创新
			  collapsed:: true
				- 预下载时长的动态调整机制
					- motivation
						- 解释预下载: 在播放上当前chunk的时候, 就要对下一个chunk进行下载
						- 一个chunk的首次下载, 需要传输的数据量最大, 变化也最大(80ms-260ms), 需要进行自适应的调整.
					- 基本过程
						- 在每个决策的时间点, 都去计算PDD:
							- 首先把PDD设成最小值 (0.1s)
							- 按照PDD预测视点, 并根据预测结果制定下一chunk首次下载决策
							- 计算该决策所需的传输时间, 如果PDD小于这个传输时间, 就说明PDD目前太小了, 我们就把PDD增大一个步长, 比如0.01s, 然后继续执行上述循环
							- 直到PDD达到我们设定的最大值, 或者不再小于决策的传输时间, 才会退出循环
		- 方法的进一步
		  collapsed:: true
			- 为更多项目增加自适应机制
				- 非预下载时的预测时间窗口的自适应
				- tiles选取范围大小的自适应
		- 项目的进一步
		  collapsed:: true
			- 使用真实的网络轨迹
			  collapsed:: true
				- 为应对网络波动而设置更长的缓冲区
					- 视点预测
						- 长期视点预测
					- tiles下载决策
						- 决策空间变大
							- 多chunk
							- 多bitrate level
						-
			- 实现下载决策的打断
			- 细化对下载决策中各个tiles的playable_time; 而不是对所有tiles设定同一个playable_time
		- ~~难点~~
		  collapsed:: true
			- MSE如何降低 ()
			- 如何保证playable
				- 动态调整预下载时间
				- modify dl_list
	- ### 360°视频的长期视点预测
	  collapsed:: true
		- 背景
			- 长期视点预测可以支持360°视频流传输系统设置更长的缓冲区，提高网络波动情况下的用户观看体验。
		- 难点
			- “历史视点轨迹”与“视频内容信息”（如显著性图等）的有效融合。
				- 空间对齐
					- 视点位置一般表示成(x, y, z)这种3D空间坐标的形式, 而显著性图一般表示成ERP格式的2d灰度图, 图片上每个像素的位置, 怎么和3d视点坐标做对齐, 是需要解决的一个问题
				- 时间变化
		- 创新
			- 设计了一个长期视点预测模型STAR-VP。该模型以空间对齐和时间变化的方式融合视点和显著性信息。
		- 成果
			- 在三个常用视点数据集上的长期视点预测（2s-5s）性能均为SOTA，并且不以牺牲短期性能为代价。
	- ### 视频播放业务用户体验建模
	  collapsed:: true
		- 目标
		  collapsed:: true
			- 基于机顶盒探针上报的传输层网络质量指标（QoS），对视频播放业务的用户体验质量（QoE）进行建模。
		- HR面
		  collapsed:: true
			- 我当时做了大量调研, 其实目前业界考虑视频QoE就是两个方面: 画面质量和卡顿情况
			- 但中国移动那边需要我们仅通过TCP传输层指标去把它们建模出来
			- 当时一个很大的难题就是卡顿预测的精确率始终提不上去. 我们尝试了各种模型, 各种特征提取方法, 都不行. 当时就怀疑说会不会是数据的问题, 然后和中国移动那边沟通, 最终明确给到的数据中同时包含直播和点播. 我就意识到, 这两种场景是要分开进行卡顿预测的, 因为直播只需要传输实时的视频画面, 缓冲区比较短, 所以只要考虑短期内的网络状况就可以; 但是点播很多时候都会提前下载一分多钟的视频, 要预测点播是否出现卡顿, 就要考虑更长一段时间的网络状况.
			- 所以我之后将直播和点播数据分开, 分别使用不同大小的时间窗口进行数据预处理, 分别训练模型对卡顿进行预测. 最终将卡顿预测的精确率从70%提升到了85%
			  collapsed:: true
				- 获取 json中multisetVodInfo中的stbPlayingStatus。
				  1）stbPlayingStatus为1时直播，
				  2）stbPlayingStatus为10时，判断m3u8List，m3u8List不为空且m3u8ReqCnt总和大于10为直播，其他为点播
				  3）stbPlayingStatus为其他值时，为点播
		- 进一步
		  collapsed:: true
			- 目前只是将QoE建模出来, 可以识别质差用户了, 但是那些质差用户具体是因为什么原因而体验质量差, 又可以做哪些调整去提高用户体验质量, 是可以进一步去做的问题
		- 难点
		  collapsed:: true
			- 仅通过传输层指标建模QoE。
			- 缺少真实的QoE标签进行模型训练；
			- ~~筛选机顶盒探针采集的海量指标；~~
			  collapsed:: true
				- 指标
					- ==syn 包个数==
					- fin / rst 包个数
					- ==TCP 滑动窗口大小==
						- 流量控制
					- RTT
					- 握手时延 (第一次, 第二次)
					- 下/上行
						- 下行总包数
						- 下行重传包数
						- 下行乱序包数
						- ==下行有效字节数==
						- 下行总字节数
		- 方法
		  collapsed:: true
			- 具体的QoE模型
			  collapsed:: true
				- QoE
				  collapsed:: true
					- 画面质量 (对数建模)
						- 下行有效字节数
					- 卡顿情况 (指数建模)
						- 卡顿预测
							- SYN包数
							- TCP滑动窗口大小
							- 下行总字节数
					- 时延 (指数建模)
					- 丢包 (指数建模)
			- ~~主成分分析~~
			  collapsed:: true
				- 主成分分析
				- 因子分析
				  collapsed:: true
					- [浅谈主成分分析与因子分析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/37755749)
						- 主成分分析主要用来做指标降维
						-
					- [The Fundamental Difference Between Principal Component Analysis and Factor Analysis (theanalysisfactor.com)](https://www.theanalysisfactor.com/the-fundamental-difference-between-principal-component-analysis-and-factor-analysis/)
						- ==PCA is a linear combination of variables; Factor Analysis is a measurement model of a [latent variable](https://www.theanalysisfactor.com/what-is-a-latent-variable/).==
						-
			- 基于心理学定律建模QoE
			  collapsed:: true
				- 然后我们基于两个心理学定理, 就是韦伯-费希纳定律和IQX假设, 分别对两项进行对数建模和指数建模; 这相当于完成了QoS指标向QoE指标的转化. 最终总的QoE表示成两项QoE指标的加权和的形式
					- 韦伯-费希纳定律
						- 视频画面质量
						  collapsed:: true
							- [图像质量评价指标之 PSNR 和 SSIM - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/50757421)
							- PSNR (Peak Signal-to-Noise Ratio) 峰值信噪比
							- SSIM (Structural SIMilarity) 结构相似性
						- bitrate
					- IQX假设
						- 卡顿时间/频率
						- 丢包率
				- 延迟, 重传, 卡顿
			- 业界建模QoE的方式
			  collapsed:: true
				- 简单来说, QoE就是两个方面, 一是视频清不清晰, 而是视频流不流畅; 因此建模指标就是画面质量, 初始延迟, 卡顿时间
				- 关键的问题在于: 怎么得到这些建模指标, 以及怎么利用这些建模指标建模QoE
				- ITU-T P.1203
				  collapsed:: true
					- 图示
						- ![image.png](../assets/image_1711764757135_0.png){:width 400,:height 800}
					- 模块
						- 视频质量评估模块
						- 音频质量评估模块
						- 质量整合模块
							- 音视频质量整合
							- 加入重缓冲的影响
					- 模型输入
						- 显示设备信息
							- 分辨率
							- 设备类型 (手机? 电脑? 电视?)
						- 视频信息
							- ==码率==
							- ==帧率==
							- 编码信息
						- 音频信息
							- 码率
							- 采样率
						- 初始加载时延 + 卡顿事件信息
							- 事件开始时间
							- 事件持续时长
						-
				- 爱奇艺的QoE建模方案
				  collapsed:: true
					- 考虑到的指标有
						- 码率大小
						- 卡顿
						- ==码率切换==
			- 时间序列分类算法（随机森林、LSTM、Transformer等）
			  collapsed:: true
				- 随机森林
					- 随机森林是什么?
					  collapsed:: true
						- 见字如面
							- 随机森林
								- 森林
									- 基本单元是决策树
									- 成百上千棵就可以叫做森林 -- (集成学习方法)
								- 随机
									- 随机性体现在：在构建基学习器的过程中，随机选择样本、随机选择特征 (从所有特征中随机选取选取一个包含 k个属性的子集)。
							- 详细
								- 如果读者接触过决策树（Decision Tree）的话，那么会很容易理解什么是随机森林。随机森林就是通过集成学习的思想将多棵树集成的一种算法，它的基本单元是决策树，而它的本质属于机器学习的一大分支——集成学习（Ensemble Learning）方法。随机森林的名称中有两个关键词，一个是“随机”，一个就是“森林”。“森林”我们很好理解，一棵叫做树，那么成百上千棵就可以叫做森林了，这样的比喻还是很贴切的，其实这也是随机森林的主要思想--集成思想的体现。“随机”的含义我们会在下边部分讲到。
						- 直观
							- 其实从直观角度来解释，每棵决策树都是一个分类器（假设现在针对的是分类问题），那么对于一个输入样本，N棵树会有N个分类结果。而随机森林集成了所有的分类投票结果，将投票次数最多的类别指定为最终的输出，这就是一种最简单的 Bagging 思想。
					- 决策树是什么?
					  collapsed:: true
						- [一文看懂决策树 - Decision tree（3个步骤+3种典型算法+10个优缺点） (easyai.tech)](https://easyai.tech/ai-definition/decision-tree/)
						- 决策树, 就是通过树形结构做决策; 或者说完成分类 (不一定是二叉树)
							- 根节点：包含样本的全集
							- 内部节点：对应特征属性的判断
							- 叶节点：最终类别
						- 决策树学习的 3 个步骤
							- **特征选择**
								- 特征选择决定了使用哪些特征来做判断。在训练数据集中，每个样本的属性可能有很多个，不同属性的作用有大有小。因而特征选择的作用就是筛选出跟分类结果相关性较高的特征，也就是分类能力较强的特征。在特征选择中通常使用的准则是：==信息增益==。
							- **决策树生成**
								- 选择好特征后，就从根节点触发，对节点计算所有特征的信息增益，选择信息增益最大的特征作为节点特征，根据该特征的不同取值建立子节点；对每个子节点使用相同的方式生成新的子节点，直到信息增益很小或者没有特征可以选择为止。
							- **决策树剪枝**
								- 剪枝的主要目的是对抗「过拟合」，通过主动去掉部分分支来降低过拟合的风险。
				- [[LSTM]]
				- [[Transformer]]
			- ==识别出质差用户之后, 怎么进一步诊断质差原因?==
			  collapsed:: true
				- 我们可以坚持各个网络指标, 比如带宽, 时延, 丢包等, 每个指标都有一个正常的范围, 如果某些指标异常了, 比如带宽, 我们就提带宽, 比如时延丢包比较严重, 我们就做一些拥塞控制上的优化
			- trivial
			  collapsed:: true
				- gpt
					- 数据分析：通过收集和分析大量的用户体验数据，运营商可以识别出问题发生的模式和趋势。例如，他们可以检查特定地区或特定时间段内的用户体验质量是否普遍较差，以确定是否存在地域性或时间性问题。他们还可以比较不同用户群体之间的体验差异，以了解问题是否与特定用户群体相关。
					- ==网络监测工具==：运营商可以利用网络监测工具来监测网络的运行状况。这些工具可以提供关于==带宽==利用率、==网络延迟==、==丢包==率等方面的实时数据。通过监测这些指标，可以发现网络中的瓶颈和异常情况，并进一步分析与用户体验质量差相关的原因。
					- 用户反馈：网络运营商可以积极收集用户的反馈和投诉。用户可能会报告视频播放过程中遇到的问题，如缓冲慢、卡顿、画面模糊等。这些反馈可以为运营商提供宝贵的线索，帮助他们了解用户体验差的具体情况和可能的原因。
					- 网络诊断工具：网络运营商可以使用网络诊断工具来进一步分析和诊断用户体验差的原因。这些工具可以提供更详细的网络参数和指标，如传输时延、包丢失率、网络拓扑等。通过分析这些数据，运营商可以确定网络中存在的问题，如==网络拥塞==、路由问题、==服务器负载==等，并进一步优化网络配置。
					- 实地调查：在某些情况下，网络运营商可能需要进行实地调查，以了解用户体验差的具体原因。他们可以派遣技术人员前往用户投诉集中的区域，检查网络设备、基站等设施是否正常运行，以及是否存在其他外部因素影响网络性能，如建筑物遮挡、干扰源等。
				- ==诊断出原因之后可以进行哪些针对性的调整?==
				  collapsed:: true
					- ==带宽==增加：如果发现用户体验差是由于带宽不足引起的，网络运营商可以增加相应地带宽，以提供更好的视频流畅度和加载速度。
					- 降低==延迟==：如果延迟是导致用户体验差的主要原因，运营商可以[[#red]]==优化网络路由==、减少==数据包丢失==等，以降低延迟，提高用户观看视频时的响应速度。
					- ==网络拥塞==缓解：如果网络拥塞是导致用户体验差的原因，网络运营商可以通过增加服务器容量、[[#red]]==优化网络拓扑==、改善流量管理策略等方式来缓解网络拥塞情况，从而提供更稳定的视频播放体验。
					- [[#red]]==服务器负载平衡==：如果服务器负载过重导致用户体验差，网络运营商可以通过负载均衡技术将流量分散到多个服务器上，以提高服务器的处理能力和响应速度。
			- 机顶盒探针是什么?
			  collapsed:: true
				- 软探针终端软件是一种安装在智能机顶盒上的APK软件，其中包含的软探针安全软件模块可以根据安全监测的需要，对进出==机顶盒网口==的所有IP流量进行被动监测和抓包，自动识别视频与网络数据，并对其进行各项参数统计，定期将这些统计参数通过指定通信协议（如TR069等）上报到云端软探针监测平台的数据采集服务器。机顶盒软探针安全模块采集的数据主要来源于智能机顶盒底层播放器、网路接口和智能操作系统。通过实时抓取和分析网络报文，获取所有网络环境数据；通过机顶盒系统提供的相关接口，采集系统内存、CPU、网络连接方式等机顶盒系统数据；通过平台主动下发网络诊断任务，采集相应的任务执行结果，即网络探测数据，按监测平台需求对网络环境数据、机顶盒系统数据和网络探测数据进行预处理后上报到监测平台，为定位智能机顶盒安全问题提供可靠依据。
		- 亮点
		  collapsed:: true
			- QoE公式超参调优目标的设定；
			- 对直播和点播场景下的模型设置不同的时间感受野。
		- 成果
		  collapsed:: true
			- 提高了质差用户QoE的区分度，卡顿预测精确率提升至85%；模型已在多省现网上进行了实际验证与部署。
	-
	- [5个C++硬核就业方向，剖析其详细C++学习路线及实战项目，包含：Qt开发、音视频流媒体开发、后端开发、DPDK网络编程、Linux内核。总有一个适合你！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV13p4y1P7nt/?spm_id_from=333.1007.0.0&vd_source=599fbcc1d46a99910a3f21226efa36a4)
	  collapsed:: true
		- 应届生, 各个C/C++开发的方向都可以投
			- ![image.png](../assets/image_1714218110752_0.png){:width 700, :height 400}
			- 量化
			- 车企
			- 网络
			- 存储
			- 音视频
			- 游戏
		- 换公司不要太频繁, 换行业也不要太频繁
			- 最短也要待够一年半(18个月); 一般三年半(42个月)才不算频繁
	-
-
- ## 八股
  collapsed:: true
	- [InterviewGuide大厂面试真题](https://top.interviewguide.cn/)
	- ### 数据结构
	  collapsed:: true
		- 常用的数据结构
		  collapsed:: true
			- 数据的逻辑结构
			  collapsed:: true
				- 集合
				- 线性表
				  collapsed:: true
					- 顺序表
					- 链表
					- 栈
					- 队列
				- 树
				  collapsed:: true
					- 二叉树
					- 平衡二叉树
					- 二叉排序树
					- 哈夫曼树
				- 图
				  collapsed:: true
					- 有向图
					- 无向图
			- 数据的物理结构
				- 顺序存储
				- 链式存储
				- 索引存储
				- 散列存储
		- 排序算法
		  collapsed:: true
			- 分类
				- 插入排序
					- 简单插入排序
					- 希尔排序
				- 交换排序
					- 冒泡排序
					- 快速排序
				- 选择排序
					- 简单选择排序
					- 堆排序
			- 简单排序的空间复杂度都为O(1), 时间复杂度都为O(n2)
	- ### 计算机网络
	  collapsed:: true
		- [在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？](https://top.interviewguide.cn/issue/581)
		  collapsed:: true
			- [在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？_计算机网络说明在web输入一个网址,按下回车后的整个工作过程-CSDN博客](https://blog.csdn.net/qq_41854911/article/details/128088976)
				- URL解析: 得到域名
				  collapsed:: true
					- 协议://服务器域名/文件路径
				- 域名 --> 目的IP地址: DNS (域名系统)
				  collapsed:: true
					- 所以域名的层级关系类似一个树状结构：
						- 根 DNS 服务器
						- 顶级域 DNS 服务器（com）
						- 权威 DNS 服务器（[http://server.com](https://link.zhihu.com/?target=http%3A//server.com)）
					- 域名解析的工作原理
						- [客户端](https://www.zhihu.com/search?q=%E5%AE%A2%E6%88%B7%E7%AB%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1657140394%7D)首先会发出一个 DNS 请求，问 [http://www.server.com](https://link.zhihu.com/?target=http%3A//www.server.com) 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。
						- 本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 [http://www.server.com](https://link.zhihu.com/?target=http%3A//www.server.com)，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 [http://www.server.com](https://link.zhihu.com/?target=http%3A//www.server.com) 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。
						- 根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“[http://www.server.com](https://link.zhihu.com/?target=http%3A//www.server.com) 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”
						- 本地 DNS 收到顶级[域名服务器](https://www.zhihu.com/search?q=%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1657140394%7D)的地址后，发起请求问“老二， 你能告诉我 [http://www.server.com](https://link.zhihu.com/?target=http%3A//www.server.com) 的 IP 地址吗？”
						- 顶级域名服务器说：“我给你负责 [http://www.server.com](https://link.zhihu.com/?target=http%3A//www.server.com) 区域的权威 DNS 服务器的地址，你去问它应该能问到”。
						- 本地 DNS 于是转向问权威 DNS 服务器：“老三，[http://www.server.com](https://link.zhihu.com/?target=http%3A//www.server.com)对应的IP是啥呀？” [http://server.com](https://link.zhihu.com/?target=http%3A//server.com)的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。
						- 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
						- 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。
				- 发送TCP连接请求数据报 (三次握手建立连接)
				- 目的IP地址 --> 下一跳IP地址 : 路由表
				  collapsed:: true
					- 判断是否在同一网段内
						- 是: 下一跳ip地址就是目的ip地址
						- 否: 下一跳ip地址就设成默认网关地址, 让路由器帮忙做路由选择和存储转发
					- 一般非路由器设备的路由表中, 只有默认网关的ip地址
					- 路由选择算法
						- [路由选择协议 RIP、OSPF、BGP 详解_bgp ospf rid-CSDN博客](https://blog.csdn.net/weixin_43941364/article/details/105509724)
						  collapsed:: true
							- 内部网关协议
							  collapsed:: true
								- RIP
									- ✅ 它是一种分布式的、 `基于距离向量` 的路由选择协议。
									- ✅ 它要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。
								- OSTF
									- “开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。
									- “最短路径优先” 是因为使用了 Dijkstra 提出的最短路径算法 SPF
							- 外部网关协议
							  collapsed:: true
								- BGP
									- 不同自治系统的路由器之间交换路由信息的协议。
				- 下一跳IP地址 --> MAC地址 : ARP协议
				  collapsed:: true
					- ARP缓存
					- 广播ARP请求分组
					- 单播ARP响应分组
				- 发送 HTTP 请求
				  collapsed:: true
					- 建立 TCP 连接之后，浏览器向 Web 服务器发起一个 HTTP 请求（如果是HTTPS协议，发送HTTP 请求之前还需要完成TLS四次握手）；
				- 服务器处理请求并返回数据
				  collapsed:: true
					- 服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。
				- 浏览器渲染
				  collapsed:: true
					- 浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM（Document Object Model; 即文档对象模型）树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。
			- [字节跳动，差点跪在一面！ (qq.com)](https://mp.weixin.qq.com/s/l0Q6B76Azs_MasHeHuLelQ)
			  collapsed:: true
				- DNS 解析：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先把域名转换成相应 IP 地址。
				- TCP 连接：浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP 三次握手建立好连接。
				- 建立TCP协议时，需要发送数据，发送数据在网络层使用IP协议， 通过IP协议将IP地址封装为IP数据报；然后此时会用到ARP协议，主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，找到目的MAC地址；
				- IP数据包在路由器之间，路由选择使用OPSF协议， 采用Dijkstra算法来计算最短路径树，抵达服务端。
				- 发送 HTTP 请求：建立 TCP 连接之后，浏览器向 Web 服务器发起一个 HTTP 请求（如果是HTTPS协议，发送HTTP 请求之前还需要完成TLS四次握手）；
				- 处理请求并返回：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。
				- 浏览器渲染：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。
				-
		- TCP & UDP
		  collapsed:: true
			- ==TCP包头 & UDP包头==
			  collapsed:: true
				- UDP包头 (基础)
				  collapsed:: true
					- 源端口
					- 目的端口
					- 数据包长度
						- UDP头部和UDP数据的总字节长度
					- 校验和
						- 对整个数据包进行校验
				- TCP包头
					- 基础
						- 源端口
						- 目的端口
						- 首部长度 (注意这里仅是首部长度, 而非UDP的 "首部+数据" 长度)
						- 校验和
					- 面向连接
						- SYN
						- ACK
						- FIN
						- RST
					- 可靠
						- 无差错
							- 校验和
						- 有序, 不重 --> 序号机制
							- 顺序号
							- 确认号
						- ~~不丢~~
					- 流量控制 --> 滑动窗口机制
						- 滑动窗口大小
					- ~~拥塞控制~~
			- [TCP和UDP的区别](https://top.interviewguide.cn/issue/469)
			  collapsed:: true
				- ![image.png](../assets/image_1711810507185_0.png){:width 400,:height 800}
				- ![image.png](../assets/image_1711810521473_0.png){:width 400,:height 800}
			- [TCP是如何保证可靠传输的？](https://top.interviewguide.cn/issue/470)
			- [封包和拆包你听说过吗？它是基于TCP还是UDP的？](https://top.interviewguide.cn/issue/458)
			  collapsed:: true
				- 封包和拆包都是基于TCP的概念。因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。
				- 封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。
				- 拆包：接收方在接收到报文后提取包头中的长度信息进行截取。
			- [TCP和UDP的使用场景](https://top.interviewguide.cn/issue/694)
			  collapsed:: true
				- TCP协议适用于对可靠性要求较高的场景
					- 传输大文件
					- 需要确保所有数据都能到达接收端的应用，
					- HTTP, FTP, SMTP, POP3, Telnet
				- UDP协议适用于对实时性要求较高的场景
					- 例如音视频流媒体、在线游戏等 。
					- TFTP
					- SNMP
					  collapsed:: true
						- 简单网络管理协议SNMP (Simple Network Management Protocol)是Internet协议网络中用于管理和监控联网设备的一种网络协议。
					- DNS
			- [具体说一下计算机网路三握四挥中的四挥？尽可能说的具体点](https://top.interviewguide.cn/issue/4)
			  collapsed:: true
				- ![image.png](../assets/image_1710909381454_0.png){:width 400,:height 800}
				- ![image.png](../assets/image_1710909392112_0.png){:width 400,:height 800}
				- MSL
					- MSL 是 Maximum Segment Lifetime 的英文缩写，可译为“报文最大生存时间/最长报文段寿命”，它是任何 ==TCP segment在网络上存在的最长时间==，超过这个时间该报文就会被丢弃，也就是说任何 TCP Segment在网络上的存活时间都不会超过MSL.
			- TCP为什么要进行三次握手? 两次不行吗?
			  collapsed:: true
				- 序号机制: 三次握手是保证发送方和接收方都将序号告知对方, 并确认对方已收到的最小次数
				  collapsed:: true
					- 因为TCP为了实现可靠传输, 所以要用到一个序号机制:  就是给每个字节编号, 并将报文段的第一个字节的序号作为报文段的序号, 发送报文段时不仅要说明该报文段的序号, 还要说明想接收的下一个报文段的序号是什么, 从而实现可靠传输
					  发送方和接收方为了将序号告知对方, 并确认对方已收到, 至少要进行三次握手
				- 阻止重复历史连接的初始化
				  collapsed:: true
					- 例子: 如果A向B发送完连接请求报文段之后, A发生了宕机, 重启之后又向B发送了第二个请求连接报文段. 结果旧报文段先到达B, 如果采用两次握手, B会直接单方面建立连接, 并且开始发送数据, 直到A发现收到的报文段的seq字段值不对, 发送给B的RST报文段被收到; 这就造成了资源浪费.
			- [四次挥手中的ack链接和之后的释放链可以合并吗？/四次挥手中确认报文和释放连接可以同时发送吗？](https://top.interviewguide.cn/issue/689)
			  collapsed:: true
				- [记录一下，TCP延迟确认和Nagle - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/552143582)
				- 如果开启延迟确认机制 (服务器不在接收到FIN报文段后立即发送ACK报文段), 就可以; 否则不行
			- [==UDP怎么实现可靠传输？==](https://top.interviewguide.cn/issue/644)
			  collapsed:: true
				- 传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。
				- 可靠
				  collapsed:: true
					- 无差错 (UDP已实现)
					- 有序; 不重
						- Packet Header 中的序号机制; seq, ack
							- 每个报文的序号严格递增, 重传报文的序号会变化 ([[#green]]==这样的话如何保证有序?==)
								- 可以更加精确计算 RTT，没有 TCP 重传的歧义性问题;
								- 可以支持乱序确认，防止因为丢包重传将当前窗口阻塞在原地，而 TCP 必须是顺序确认的，丢包时会导致窗口滑动;
						- Frame Header 中的Stream ID 和 Offset
							- Stream ID 作用：多个并发传输的 HTTP 消息，通过不同的 Stream ID 加以区别;
							- Offset 作用：类似于 TCP 协议中的 Seq 序号，保证数据的顺序性和可靠性;
							- Length 作用：指明了 Frame 数据的长度。
							- QUIC 通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息，可以支持乱序确认而不影响数据包的正确组装，摆脱了TCP 必须按顺序确认应答 ACK 的限制，解决了 TCP 因某个数据包重传而阻塞后续所有待发送数据包的问题。
					- 不丢
						- 重传机制 (ACK帧)
		- HTTP
		  collapsed:: true
			- [HTTPS和HTTP的区别](https://top.interviewguide.cn/issue/197)
			  collapsed:: true
				- HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，HTTPS协议是由SSL+HTTP协议构建的可进行==加密传输==、==身份认证==的网络协议，要比http协议安全。
				- 端口不一样: HTTP 80 ; HTTPS 443
			- [http1.0 / 1.1 / 2 / 3的区别](https://top.interviewguide.cn/issue/699)
			  collapsed:: true
				- [HTTP 1.0、1.1、2.0、3.0区别 - 简书 (jianshu.com)](https://www.jianshu.com/p/cd70b8e90d00)
			- [常见的HTTP状态码有哪些？](https://top.interviewguide.cn/issue/516)
			- [HTTP请求和响应报文有哪些主要字段？](https://top.interviewguide.cn/issue/331)
			  collapsed:: true
				- [HTTP请求报文和响应报文详解 - 掘金 (juejin.cn)](https://juejin.cn/post/6931636106710482958)
					- ```
					  POST /user HTTP/1.1                       // 请求行
					  Host: www.user.com
					  Content-Type: application/x-www-form-urlencoded
					  Connection: Keep-Alive
					  User-agent: Mozilla/5.0.                  // 以上是请求头
					  （此处必须有一空行 |                         // 空行分割header和请求内容 
					  name=world                                // 请求体(可选，如get请求时可选)
					  ```
					- ```
					  HTTP/1.1 304 Not Modified
					  Date：Sat, 15 Oct 2011 15:39:29
					  (空行)                                      
					  (空响应体)
					  ```
					- GET www.url.com HTTP/1.1
					- HTTP/1.1 200 OK
			- [GET 和 POST请求的本质区别是什么-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1915518)
		- IP
		  collapsed:: true
			- IP包头
				- 基础
					- 源IP, 目的IP
					- 包头长度, 总长度
					- 首部校验和
				- 分片重组相关
					- **Identifier**
					  collapsed:: true
						- 用于数据包在分段重组时标识其序列号。
					- **Flags**
					  collapsed:: true
						- DF
						- MF
					- **Fragment Offset**
					  collapsed:: true
						- The **Fragment Offset** field (13 bits) is used to indicate the starting position of the data in the fragment in relation to the start of the data in the original packet.
				- 版本
				- TOS
				- TTL
				- 协议
				- 可选字段
			- IPV4 vs. IPV6
			  collapsed:: true
				- 最直观的一点: IPV6地址空间更大
				- IPV6不需要DHCP就可以自动配置IP地址
				- IPV6首部优化
					- 取消校验和字段
					- 取消分片,重组相关字段
					- 取消options字段
				- 详细
				  collapsed:: true
					- IPV4
					  collapsed:: true
						- 地址分类
						  collapsed:: true
							- ![image.png](../assets/image_1711597438689_0.png){:width 400,:height 800}
							-
						- 最大主机数
						  collapsed:: true
							- ![image.png](../assets/image_1711597491996_0.png){:width 400,:height 800}
							-
					- IPV6
						- IPV6可以分配的ip地址更多
							- 4个8位二进制数
							- 8个16位二进制数
						- IPV6的亮点
							- IPv6 可⾃动配置，即使没有 DHCP 服务器也可以实现⾃动分配IP地址，真是便捷到即插即⽤。
							- IPv6 包头包⾸部⻓度采⽤固定的值 40 字节，去掉了包头校验和，简化了⾸部结构，减轻了路由器负荷，⼤⼤**提⾼了传输的性能**。
							- IPv6 有应对伪造 IP 地址的⽹络安全功能以及防⽌线路窃听的功能，⼤⼤**提升了安全性**。
						- IPv6 相比 IPv4 的首部改进：
							- 取消了首部校验和字段。 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。
							- 取消了分片/重新组装相关字段。 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。
							- 取消选项字段。 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 40 字节。
			- [5.2 ping 的工作原理 | 小林coding (xiaolincoding.com)](https://www.xiaolincoding.com/network/4_ip/ping.html#ping-%E6%9F%A5%E8%AF%A2%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8)
			  collapsed:: true
				- 通过 ICMP回送请求报文 和 ICMP回送响应报文
				- ping的架构是跨层封装--应用层直接调用网络层ICMP服务，应用程序调用原始套接字而不是TCP或UDP的套接字，也就是ping没有传输层。
			- 特殊地址
			  collapsed:: true
				- 127.0.0.1：回环地址。该地址指电脑本身，主要预留测试本机的TCP/IP协议是否正常。只要使用这个地址发送数据，则数据包不会出现在网络传输过程中。
				- 10.x.x.x、172.16.x.x～172.31.x.x、192.168.x.x：这些地址被用做内网中。用做私网地址，这些地址不与外网相连。
				- 255.255.255.255：广播地址
				- 0.0.0.0：这个IP地址在IP数据报中只能用作源IP地址，这发生在当设备启动时但又不知道自己的IP地址情况下。
				- 127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗
					- localhost是127.0.0.1这个ip地址所对应的域名
					- 0.0.0.0 表示的是 "未指定", 在不同的地方有不同的含义
						- 在服务器中，0.0.0.0指的是本机上的所有IPV4地址
							- 比如一个主机有两个IP地址，192.168.1.1 和 10.1.2.1，并且该主机上的一个服务监听的地址是0.0.0.0,那么通过两个ip地址都能够访问该服务。
							- 0.0.0.0 只能作为源IP地址, 不能作为目的IP地址
						- 在路由中，0.0.0.0表示的是默认路由，即当路由表中没有找到完全匹配的路由的时候所对应的路由。
		- QUIC
		  collapsed:: true
			- [视频面试传输协议到底是TCP还是UDP - 掘金 (juejin.cn)](https://juejin.cn/post/6867043669682651143)
			-
		- Socket
		  collapsed:: true
			- [(9 封私信 / 80 条消息) socket编程到底是什么？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/29637351/answer/1934423848)
			- 定义
				- socket是不同主机之间进程进行通信的一种方式
				- 服务器和客户端各自维护一个“文件”，在建立连接打开后，可以向文件写入内容供对方读取或者读取对方写入的内容，通讯结束时关闭文件。
			- TCP 网络编程
				- ![image.png](../assets/image_1711891850396_0.png){:width 400,:height 800}
		- 其它
		  collapsed:: true
			- [子网掩码的作用是什么？](https://top.interviewguide.cn/issue/970)
			  collapsed:: true
				- 子网掩码的作用是将IP地址分成网络号和主机号两部分。我们就可以得知当前IP地址所在的网络
					- 划分网络
					- 判断两个IP地址是否在同一网段内
			- DNS在哪一层
			  collapsed:: true
				- 应用层
			- ICMP在哪一层?
			  collapsed:: true
				- 网络层
			- IEEE 802.3协议在哪层
			  collapsed:: true
				- 通常说, IEEE 802.3协议是物理层协议。
				- 但该协议不仅定义了物理规范, 还定义了 "数据链路层" 的 "介质访问控制子层" 中的一些内容, 比如CSMA/CD。
			- CSMA/CD和CSMA/CA的基本思想和主要区别
			  collapsed:: true
				- CSMA/CD
					- 意思是载波侦听多路访问, 碰撞检测
					- 载波侦听是指在发送数据前先检测信道上有无其他站点正在发送数据, 有则暂时不发送;
					  碰撞检测是指在发送数据的过程中也一直检测信道上的电压变化, 检测是否发生了冲突, 若出现冲突则中止发送
				- CSMA/CA
					- 意思是载波侦听多路访问, 碰撞避免
					- 一个站点在发送数据前, 要先广播告知其它站点, 让它们在一段时间内不要发送数据, 从而尽可能实现碰撞避免
				- 区别
					- CSMA/CD 只能检测碰撞, 但没有办法避免;  CSMA/CA 无法检测碰撞, 只能尽量避免
					- CSMA/CD 用于总线型以太网; CSMA/CA 用于无线局域网
	- ### 深度学习
	  collapsed:: true
		- 介绍一下CNN有哪些网络结构
		  collapsed:: true
			- (conv + ReLU + pooling) + (conv + ReLU + pooling) + (fc + ReLU) + (fc + softmax)
			  collapsed:: true
				- ```python
				  class LeNet(Module):
				  	def __init__(self, numChannels, classes):
				  		# call the parent constructor
				  		super(LeNet, self).__init__()
				  		
				          # initialize first set of CONV => RELU => POOL layers
				  		self.conv1 = Conv2d(in_channels=numChannels, out_channels=20,
				  			kernel_size=(5, 5))
				  		self.relu1 = ReLU()
				  		self.maxpool1 = MaxPool2d(kernel_size=(2, 2), stride=(2, 2))
				  		
				          # initialize second set of CONV => RELU => POOL layers
				  		self.conv2 = Conv2d(in_channels=20, out_channels=50,
				  			kernel_size=(5, 5))
				  		self.relu2 = ReLU()
				  		self.maxpool2 = MaxPool2d(kernel_size=(2, 2), stride=(2, 2))
				  		
				          # initialize first (and only) set of FC => RELU layers
				  		self.fc1 = Linear(in_features=800, out_features=500)
				  		self.relu3 = ReLU()
				  		
				          # initialize our softmax classifier
				  		self.fc2 = Linear(in_features=500, out_features=classes)
				  		self.logSoftmax = LogSoftmax(dim=1)
				  ```
			- [CNN（卷积神经网络）架构 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/46851548)
			- ![image.png](../assets/image_1711627569521_0.png){:width 400,:height 800}
		- 介绍一下 [[LSTM]]; 它是如何实现长短时记忆的?
		  collapsed:: true
			- 核心是 cell state 和 三个门控机制: 遗忘门, 输入门, 输出门
			- 三个门的输入都是 "上一时刻的隐藏状态" 和 "当前时刻的输入", 它们分别决定要cell state遗忘什么, 要向cell state中输入什么, 要从cell state中输出什么
			- 输出的就是当前时刻的隐藏状态 ($h_t$)
			- cell state就对应了长期记忆; hidden state就对应了短期记忆
		- Transformer
		  collapsed:: true
			- [Transformer面试题](https://github.com/DA-southampton/NLP_ability/blob/master/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/Transformer/%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90(1)%E2%80%94%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8Transformer%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%81%B5%E9%AD%8220%E9%97%AE%E5%B8%AE%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E5%AE%9ATransformer.md)
				- 为什么用多头?
				  collapsed:: true
					- 多头保证了transformer可以注意到不同子空间的信息，捕捉到更加丰富的特征信息。
					- 如图7所示，可以看到所谓的多头注意力机制其实就是将原始的输入序列进行多组的自注意力处理过程；然后再将每一组自注意力的结果拼接起来进行一次线性变换得到最终的输出结果。
						- ![image.png](../assets/image_1711632885295_0.png){:width 250}
					-
						-
						-
				- Transformer为什么Q和K使用不同的权重矩阵生成，为何不能使用同一个值进行自身的点乘？
				  collapsed:: true
					- 注解：简单回答就是，使用Q/K/V不相同可以保证在不同空间进行投影，增强了表达能力，提高了泛化能力。
					- 直接拿K和K转置点乘的话，你会发现attention score 矩阵是一个对称矩阵。因为是同样一个矩阵，都投影到了同样一个空间，所以泛化能力很差。
				- Transformer计算attention的时候为何选择点乘而不是加法？两者计算复杂度和效果上有什么区别？
				  collapsed:: true
					- 答案解析：为了计算更快。矩阵加法在加法这一块的计算量确实简单，但是作为一个整体计算attention的时候相当于一个隐层，整体计算量和点积相似。
				- 为什么在进行softmax之前需要对attention进行scaled（为什么除以dk的平方根），并使用公式推导进行讲解
				  collapsed:: true
					- [(9 封私信 / 80 条消息) transformer中的attention为什么scaled? - 知乎 (zhihu.com)](https://www.zhihu.com/question/339723385)
		- 其它
			- 在做神经网络的时候, 可以将全部的初始参数设置为0吗?
			  collapsed:: true
				- **对称性问题**：如果在网络中的所有权重都开始于0，那么在反向传播的过程中，每层的所有神经元将会以相同的方式更新, 都只会学习到一个相同的特征. 我们希望的是模型学习到的特征尽可能多样化
				- 常用的参数初始化方法
					- 随机初始化; 从均匀分布或者正态分布中采样
					- Xavier (读作ZV2) (以下的方法都是给均匀分布设定不同的方差)
					  collapsed:: true
						- ![image.png](../assets/image_1711629621816_0.png){:width 400,:height 800}
					- He
					- 其它
					  collapsed:: true
						- LeCun (乐酷)
						- ![image.png](../assets/image_1711630243937_0.png){:width 400,:height 800}
			- 模型评估的方法
			  collapsed:: true
				- 留出法（Hold-out）
				  collapsed:: true
					- **留出法是机器学习中最常见的评估方法之一，它会从训练数据中保留出验证样本集，这部分数据不用于训练，而用于模型评估**。
				- 交叉验证法（Cross Validation）
				  collapsed:: true
					- **留出法的数据划分，可能会带来偏差**。在机器学习中，另外一种比较常见的评估方法是交叉验证法—— K折交叉验证对K个不同分组训练的结果进行平均来减少方差。因此模型的性能对数据的划分就不那么敏感，对数据的使用也会更充分，模型评估结果更加稳定，可以很好地避免上述问题。
				- 自助法（Bootstrap）
				  collapsed:: true
					- 对于大小为n的样本集合，进行n次有放回的随机抽样，得到大小为n的训练集，n次采样过程中，有的样本没有被抽出过，将这些没被抽出的样本作为验证集，进行模型验证，这就是自助法的验证过程。
					-
			- 我们公司现在有一批产品的图片需要处理, 这些图片中可能有一些是不符合公司标准的, 比如有一些logo, 有一些水印, 有一些损坏, 你的任务是设计一个自动检测系统, 来去除这些不符合标准的图像. 你可以从算法的角度讲一下这个题吗?
			  collapsed:: true
				- poe
					- 准备模型输入
						- 图像预处理：首先，对原始图像进行预处理，包括统一图像大小, 归一化之类，以便后续算法能够更好地处理图像。
						- 特征提取：使用计算机视觉技术，提取图像中的特征。这些特征可以包括颜色直方图、纹理特征、边缘信息等。特征提取的目的是将图像转换为计算机可以理解和处理的数值表示形式。
					- 准备模型输出
						- 样本标注：准备一批已经标注的图像样本，其中包含了符合公司标准和不符合公司标准的图像。标注可以通过人工标记或者半自动标记的方式进行。
					- 模型选择
						- 例如卷积神经网络（CNN）。CNN在图像处理任务中表现良好，可以学习到图像的特征表示和分类决策规则。
					- 模型训练
						- 模型训练：使用已标注的图像样本，训练一个分类模型
					- 模型测试
						- 模型评估：使用测试集评估训练好的模型的性能。评估指标可以包括准确率、召回率、精确率等，用于衡量模型对不符合标准图像的检测能力。
					- 模型投入使用
						- 不符合标准图像检测：将待处理的图像输入训练好的模型，通过模型进行预测，判断图像是否符合标准。如果模型预测为不符合标准，可以进行相应的处理操作，如去除logo、水印或修复损坏部分。
					- 模型迭代优化
						- 后续优化：根据实际应用情况，对系统进行优化和改进。可以考虑使用更复杂的模型结构、增加训练数据量、引入数据增强技术等，以提高系统的准确性和鲁棒性。
	- ### 数据库
	  collapsed:: true
		- [事务四大特性（ACID）原子性、一致性、隔离性、持久性？](https://top.interviewguide.cn/issue/283)
		  collapsed:: true
			- 事务的特性
				- Atomicity(原子性):  指一个事务具有原子性;  事务中的所有操作要么全部成功提交, 要么全部失败回滚
				- Consistency(一致性):  事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。
					- 事务按照预期生效，数据的状态是预期的状态。
					- 举例说明：张三向李四转100元，转账前和转账后的数据是正确的状态，这就叫一致性，如果出现张三转出100元，李四账号没有增加100元这就出现了数据错误，就没有达到一致性。
				- Isolation(隔离性):  多个事务并发执行时不能相互干扰。即每个事务都感觉只有自己在执行
				- Durability(持久性):  **在事务成功提交了之后，事务所变更的数据一定会保存起来，而不会因为任何故障导致数据丢失**。 (通过日志, 将宕机之前未持久化的事务完成)
				-
		- [数据库的事务隔离级别有哪些？](https://top.interviewguide.cn/issue/263)
		  collapsed:: true
			- [理解事务的4种隔离级别-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1865041)
				- 未提交读
				- 提交读
				- 可重复读
				- 串行化 (所有事务串行执行)
		- 数据库设计三大范式
		  collapsed:: true
			- 为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在==关系型数据库==中这种规则就称为范式。
			- ![image.png](../assets/image_1711677856756_0.png){:width 400,:height 800}
			- 第一范式（1NF）--属性不可分
				- 每一属性值都是不能再分的元素
				- Ex. 地址 --> 国家, 省份, 城市, 详细地址
			- 第二范式（2NF）--消除非主属性对候选码的部分函数依赖
				- 如果关系模型R属于1NF，且R中的每一个非主属性完全函数依赖于R的某个候选键，则称R属于2NF。
				- Ex. (学生ID, 课程ID, 分数, 学生姓名, 课程名称)
			- 第三范式（3NF）--再消除非主属性对候选码的传递函数依赖
				- 如果关系模型R属于2NF，且R中每个非主属性都不传递依赖于R的候选键，则称R属于3NF。
				- Ex. (学号, 姓名, 年龄, 学院名称, 学院电话)
			- BC范式（BCNF）--再消除主属性对候选码的部分和传递函数依赖
			- 第四范式 (4NF) --在消除平凡多值依赖
			-
		- 索引
		  collapsed:: true
			- 定义 以及为什么要使用B+树
			  collapsed:: true
				- 索引就是一个类似于目录的数据结构, 可以帮我们快速查找
				  collapsed:: true
					- 索引( `Index` )是帮助高效查找数据的数据结构。就好比给你一本书和一篇文章标题，如果没有目录，让你找此标题对应的文章，可能需要从第一页翻到最后一页；如果有目录大纲，你可能只需要在目录页寻找此标题，然后迅速定位文章。
				- 可以实现索引的数据结构, 以及为什么选用B+树
				  collapsed:: true
					- (1) 哈希表
						- 哈希虽然能够提供 `O(1)` 的单数据行的查询性能，但是对于 `范围查询` 和 `排序` 却无法很好支持，需全表扫描。
					- (2) 红黑树
						- 红黑树( `Red Black Tree` )是一种自平衡二叉查找树，在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。
						- 一般来说，索引本身也很大，往往不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗远远高于内存，所以评价一个数据结构作为索引的优劣最重要的指标就是查找过程中磁盘I/O次数。换句话说， `索引的结构组织要尽量减少查找过程中磁盘I/O的次数。`
						- ==磁盘I/O的次数取决于树的高度，==所以，在数据量较大时， `红黑树会因树的高度较大 (因为是二叉) 而造成磁盘IO较多` ，从而影响查询效率。
					- (3) B-Tree (绝对平衡的多路查找树)
						- B树中的B代表平衡( `Balance` )，而不是二叉( `Binary` )，B树是从平衡二叉树演化而来的。
						- 为了降低树的高度(也就是减少磁盘I/O次数)，把原来 `瘦高` 的树结构变得 `矮胖` ，B树会在 `每个节点存储多个元素` (红黑树每个节点只会存储一个元素)，并且节点中的元素从左到右递增排列。如下图所示
						  collapsed:: true
							- ![image.png](../assets/image_1711700277340_0.png){:width 666}
						- `B-Tree` 在查询的时候比较次数其实不比二叉查找树少，但在内存中的大小比较、二分查找的耗时相比磁盘IO耗时几乎可以忽略。  `B-Tree大大降低了树的高度` ，所以也就极大地提升了查找性能。
					- (4) B+Tree
						- `B+Tree` 是在 `B-Tree` 基础上进一步优化，使其更适合实现存储索引结构。InnoDB存储引擎就是用 `B+Tree` 实现其索引结构。
						- `B-Tree` 结构图中可以看到每个节点中不仅包含数据的 `key` 值，还有 `data` 值。而==每一个节点的存储空间是有限的==，如果 `data` 值较大时将会导致每个节点能存储的 `key` 的数量很小，这样会导致B-Tree的高度变大，增加了查询时的磁盘I/O次数，进而影响查询性能。在 `B+Tree` 中，所有 `data` 值都是按照键值大小顺序存放在同一层的叶子节点上，而 `非叶子节点上只存储key值信息` ，这样可以增大每个非叶子节点存储的 `key` 值数量，降低B+Tree的高度，提高效率。
					-
			- 建立索引的时候需要注意啥
			  collapsed:: true
				- 表的主键、外键必须有索引；
				- 经常查找的字段应该建立索引
				- 经常修改的字段不要建立所以
				- 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；
				- 其它
				  collapsed:: true
					- 数据量超过300的表应该有索引；
					- 经常与其他表进行连接的表，在连接字段上应该建立索引；
					- 经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；
					- 索引应该建在选择性高的字段上；
					- 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；
					- 复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：
					  collapsed:: true
						- 正确选择复合索引中的主列字段，一般是选择性较好的字段；
						- 复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；
						- 如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；
						- 如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；
						- 如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；搜索
					- 频繁进行数据操作的表，不要建立太多的索引；
					- 删除无用的索引，避免对执行计划造成负面影响；
			- 索引怎么建立
			  collapsed:: true
				- CREATE INDEX可对表增加普通索引或UNIQUE索引
					- CREATE INDEX index_name ON table_name (column_list)
					- CREATE UNIQUE INDEX index_name ON table_name (column_list)
			- 索引建立的时候可以在多个键上吗
			  collapsed:: true
				- 答：可以，联合索引
		- 关系型数据库与非关系型数据库以及别的数据库类型及名字
		  collapsed:: true
			- 关系型数据库
				- 二维表格
				- ACID, 安全性与可维护性高
				- MySQL, Oracle
			- 非关系型数据库
				- 字典 (键值对集合)
				- 并发读写能力强
				- Redis
		-
		- [如何排查一条慢SQL？可以从哪些方面入手？](https://top.interviewguide.cn/issue/496)
		  collapsed:: true
			- [面试题 MySQL的慢查询、如何监控、如何排查？_面试 慢查询排查-CSDN博客](https://blog.csdn.net/qq_42052956/article/details/111387051)
		- [Redis怎么实现分布式锁？](https://top.interviewguide.cn/issue/452)
		  collapsed:: true
			- [聊聊如何用 Redis 实现分布式锁？ - 小林coding - 博客园 (cnblogs.com)](https://www.cnblogs.com/xiaolincoding/p/16517673.html)
				- 加锁的基本思路
					- Redis 的 SET 命令有个 NX 参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁：
						- 如果 key 不存在，则显示插入成功，可以用来表示加锁成功；
						- 如果 key 存在，则会显示插入失败，可以用来表示加锁失败。
				- 加锁的详细思路
					- SET lock_key unique_value NX PX 10000
						- 使用 SET 命令带上 NX 选项来实现加锁；
						- 在 SET 命令执行时加上 EX/PX 选项，设置其过期时间；
						- 使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端；
				- 解锁
					- 先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。
					- 解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。
					- ```
					  // 释放锁时，先比较 unique_value 是否相等，避免锁的误释放
					  if redis.call("get",KEYS[1]) == ARGV[1] then
					      return redis.call("del",KEYS[1])
					  else
					      return 0
					  end
					  ```
	- ### C++
	  collapsed:: true
		- trivial
		  collapsed:: true
			- struct 和 class 的区别
			  collapsed:: true
				- **（0）定义上不同**
					- struct 是各种数据类型的组合，是一种复合数据类型，class 是一个对象的方法和属性的集合，更注重数据的安全性。
				- **（1）默认的访问属性不同**
					- struct 默认的访问属性是 public，class 默认的访问属性是 private
				- **（2）默认的继承方式不同**
					- struct 默认的继承方式是 public，class 默认的继承方式是 private。
			- 程序运行有几个过程，每个过程生成了什么文件
			  collapsed:: true
				- 图解
					- ![image.png](../assets/image_1710667984347_0.png){:width 666}
				- 巧记
					- .i -> .s -> .o 刚好是 iso
				- 预编译: .c --> .i
					- 把头文件包括进来
					- 宏展开
					- 删除注释
					- 详细
					  collapsed:: true
						- 预处理器（cpp）将所有的#define删除，并且展开所有的宏定义。
						- 处理所有的条件预编译指令，比如#if、#ifdef、#elif、#else、#endif等。
						- ==处理#include预编译指令==，将被包含的文件直接插入到预编译指令的位置。
						- ==删除所有的注释。==
						- 添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号。
						- 保留所有的#pragma编译器指令，因为编译器需要使用它们。
						- 使用 `gcc -E hello.c -o hello.i` 命令来进行预处理， 预处理得到的另一个程序通常是以.i作为文件扩展名。
				- 编译: 高级语言代码 --> 汇编代码文件 (.s)
				  id:: 65f6b52c-bf85-440c-91af-97ec490a2c26
				  collapsed:: true
					- 词法分析
						- 利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。
					- 语法分析
						- 语法分析器对由扫描器产生的tokens，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。
					- 语义分析
						- 语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。
					- 源代码优化
						- 源代码级别的一个优化过程。
					- 目标代码生成
						- 由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。
					- 目标代码优化
						- 目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。
				- 汇编: 汇编代码文件 --> 机器码文件 (.o)
				- 链接 --> 可执行文件
			- 编译过程中有哪些过程
			  collapsed:: true
				- ((65f6b52c-bf85-440c-91af-97ec490a2c26))
			- [说一说你了解的关于lambda函数的全部知识](https://top.interviewguide.cn/issue/1)
			- [C++ 11有哪些新特性？](https://top.interviewguide.cn/issue/3)
			  collapsed:: true
				- [c++11新特性，所有知识点都在这了！-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1745592)
					- **auto & decltype** --> 编译时类型推导
						- auto是从变量声明的初始化表达式获得变量的类型，
						- decltype是**以一个普通表达式作为参数**，返回该表达式的类型,而且decltype并不会对表达式进行求值。
				- [一文读懂C++右值引用和std::move - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/335994370)
			- [讲一下程序的内存分区/内存模型？](https://top.interviewguide.cn/issue/388)
			- [STL中unordered_map和map的区别和应用场景，set、unordered_set](https://top.interviewguide.cn/issue/548)
			- [select/poll/epoll的区别](https://top.interviewguide.cn/issue/480)
			- [Python和C++有什么区别？](https://top.interviewguide.cn/issue/9)
			- [Python的垃圾回收机制？](https://top.interviewguide.cn/issue/602)
			- [可以谈一下你理解的Python装饰器吗？](https://top.interviewguide.cn/issue/601)
			- [Python中*args和**kwargs的特点是什么？用法又是什么？能否放在一起使用？](https://top.interviewguide.cn/issue/971)
			- 宏和内联函数的区别
			- 为什么要引入纯虚函数
			- 重载和重写区别
			- 如何不使用final关键字让一个类无法被继承
			- 智能指针了解吗
			- 为什么c++新标准把auto_ptr删了
			- share_ptr是线程安全的吗
			- new和delete是如何实现的
			- malloc在底层是如何实现的
		- new与malloc有啥区别
		  collapsed:: true
			- 核心
				- 内存分配的位置
				  collapsed:: true
					- new操作符从**自由存储区（free store）**上为对象动态分配内存空间，而malloc函数从**堆**上动态分配内存。
						- 通过new分配的内存区域可以称为自由存储区。自由存储区可以是堆、全局/静态存储区等
				- 是否调用构造函数/析构函数
				  collapsed:: true
					- new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。如果你不嫌啰嗦可以看下我的例子
					- 详细
						- 使用new操作符来分配对象内存时会经历三个步骤：
							- 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，**原始**的，未命名的内存空间以便存储特定类型的对象。
							- 第二步：编译器运行相应的**构造函数**以构造对象，并为其传入初值。
							- 第三部：对象构造完成后，返回一个指向该对象的指针。
						- 使用delete操作符来释放对象内存时会经历两个步骤：
							- 第一步：调用对象的析构函数。
							- 第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。
			- 见字如面
			  collapsed:: true
				- new/delete是关键字, 而malloc/free是库函数, 需要引入头文件
				- 是否需要指定内存分配的大小
				  collapsed:: true
					- 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。
				- 内存分配成功时的**返回值** (返回类型安全性)
				  collapsed:: true
					- new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合**类型安全**性的操作符。而malloc内存分配成功则是返回 `void *` ，需要通过强制类型转换 `void*` 将指针转换成我们需要的类型。
				- 内存分配失败时的**返回值**
				  collapsed:: true
					- new内存分配失败时，会抛出bad_alloc异常，它**不会返回NULL**；malloc分配内存失败时返回NULL。
			- 对数组的处理
			  collapsed:: true
				- new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。
				- 至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：
		- delete与free有啥区别
		- 析构函数怎么写
		  collapsed:: true
			- 用 `~ClassName` 作为函数名去写呗
		- C++内存分布
		  collapsed:: true
			- ![image.png](../assets/image_1711767702814_0.png){:width 666}
				- 栈的空间由操作系统自动分配和释放
				- 堆的空间由程序员手动分配和释放
			- trivial
			  collapsed:: true
				- ![image.png](../assets/image_1711767474199_0.png){:width 666}
			-
			-
		- 全局变量、静态全局变量、静态局部变量和局部变量的区别
		  collapsed:: true
			- 变量可以分为：全局变量、静态全局变量、静态局部变量和局部变量。
			- 按存储区域分，全局变量、静态全局变量和静态局部变量都存放在内存的静态存储区域，局部变量存放在内存的栈区。
			- 按作用域分，全局变量在整个工程文件内都有效；静态全局变量只在定义它的文件内有效；静态局部变量只在定义它的函数内有效，并且程序仅分配一次内存，函数返回后，该变量不会消失；局部变量在定义它的函数内有效，但是函数返回后失效。
			- 静态局部变量**具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在**，==它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见==。
		- static 关键字的作用
		  collapsed:: true
			- static可以用作函数和变量的前缀
				- 对于函数来说, static的作用仅限于隐藏; 即只有在定义这个函数的文件中可以访问到该函数
				- 对于变量来说, static可以使变量内容持久; 静态数据区的变量会在程序刚开始运行时就完成唯一的一次初始化, 而且到程序运行完才会被回收.
		- 类的静态成员
		  collapsed:: true
			- 一个类的静态成员函数和静态成员变量都是归属于这个类的, 而不是某个具体对象
		- C++中一个类的静态成员变量可以被普通的成员函数访问到吗?
		  collapsed:: true
			- 是的，C++的一个类的静态成员变量可以被类的普通成员函数访问。因为静态成员变量在程序开始执行时就被创建，直到程序结束执行时才被销毁。在此期间，它一直存在，所以普通的成员函数可以访问到。
		- C++多线程，怎么用的
		- 智能指针
			- [C++ 智能指针 - xd_xumaomao - 博客园 (cnblogs.com)](https://www.cnblogs.com/xumaomao/p/15175448.html)
			  collapsed:: true
				- 作用
					- 智能指针就是将普通的指针封装为一个栈对象。 当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。
					  collapsed:: true
						- 简要的说，智能指针利用了C++ 的RAII 机制，在智能指针对象作用域结束后，会自动做内存释放的相关操作，不需要我们再手动去操作内存。
			- [【c++面试之智能指针】【万字长文】【超级详细】最详细解析四种智能指针，面试题汇总及解答，妈妈再也不担心面试官考我智能指针了。 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/609599904)
			  collapsed:: true
				- 类型
					- auto_ptr
					  collapsed:: true
						- auto_ptr是一种对资源独占的指针(和unique_ptr一样），但是它已经被unique_ptr取代，我们不应该使用它。
						- 缺点
							- 允许赋值, 安全性低
							- 只有和new对应的版本, 没有和 `new []` 对应的版本
					- unique_ptr
					  collapsed:: true
						- 对资源独占的指针
						- unique_ptr不能放在等号右边赋值, 想要将资源转移给另一个指针, 需要使用std:move()函数
					- shared_ptr
					  collapsed:: true
						- 相较于unique_ptr的独占式持有资源的特点而言，shared_ptr则是一种共享式的智能指针:多个shared_ptr可以共享同一个对象的所有权。
						- 每次指针指向某一个对象时，指针内部的引用计数会加1，当每次指针不再指向对象时，内部的引用计数会减1。当内部的引用计数减到0的时候，就会释放指向对象。
						- **shared_ptr线程安全问题[9]**
							- boost官方文档中有对此问题给出结论。我对这些结论做一下解析：
							- （1） 同一个shared_ptr被多个线程“读”是安全的.
							  这个应该很容易理解吧，因为是进行读操作，没有修改，肯定是线程安全的了。
							- （2）同一个shared_ptr被多个线程“写”是不安全的
							  假如说有两个线程同时访问一个shared_ptr对象，一个进行释放（reset)，另一个读取裸指针的值，那么最后的结果就不确定了，很可能会因为访问野指针的问题导致crash。
							- （3）共享引用计数的不同的shared_ptr被多个线程”写“ 是安全的；
							  c++ 11官方文档有说，share_ptr的计数操作具有原子性。也就是说多个线程通过多个shaped_ptr(虽然这多个shared_ptr指向的是同一个对象）进行操作，是线程安全的。
					- weak_ptr
					  collapsed:: true
						- trivial
						  collapsed:: true
							- 主要为了避免shared_ptr的循环引用问题
							- 正是因为shared_ptr的这种共享资源的特性，所以可能会产生循环引用：A中引用B, B中引用A。这样即使在程序结束后，两个资源的引用计数仍然大于等于1，导致无法释放资源，还是会产生内存泄漏。具体的例子如下：
								- ```
								  class A {
								  public:
								    shared_ptr<B> b;
								  };
								  class B {
								  public:
								    shared_ptr<A> a;
								  };
								  int main(int argc, const char * argv[]) {
								    shared_ptr<A> spa = make_shared<A>(); //资源A引用计数为1
								    shared_ptr<B> spb = make_shared<B>(); //资源B引用计数为1
								    spa->b = spb;//资源B引用计数为2
								    spb->a = spa;//资源A引用计数为2
								    return 0; 
								  } //main函数退出后，资源B和资源A强引用计数依然为1，无法释放
								  ```
							- 其实可能我们的类B内部只是想要引用一下A中的对象，B中根本无需管理它的生命周期，它不在B中创建，也不在B中销毁。这个时候我们只用将B中的对A的引用使用weak_ptr来引用，这样会更加合适，也避免了循环引用。
						- `weak_ptr` 主要用于解决 `shared_ptr` 可能产生的循环引用问题。
						- 比如有两个类A和B, A中有指向B类对象的shared_ptr, B中有指向A类对象的shared_ptr, 这就有可能产生循环引用问题
							- > "这个时候,即使所有的外部引用都已经释放了, `book` 和 `author` 对象也无法被正常销毁,因为它们之间存在循环引用,引用计数器永远不会到达0。"
						- 把一种一个类的shared_ptr改为weak_ptr即可
			- [C++ 智能指针与底层实现剖析 - 掘金 (juejin.cn)](https://juejin.cn/post/7111726931301072910)
				- # RAII
					- RAII（ `Resource Acquisition Is Initialization` ）资源获取即初始化。
					- 它是一种利用**对象**生命周期来控制程序资源（如**内存、文件句柄、网络连接、互斥量**等等）的简单技术。
					- 在**对象构造**时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象**析构**的时候释放资源。至此我们可以看到实际上就是**把一份资源的责任托管给了一个对象**。
					- 这种做法有两大好处：
						- 不需要**显式释放**资源。析构时自动调用。
						- 采用这种方式，对象所需的资源在其生命期内始终**保持有效**。
					-
		- 线程安全
		  collapsed:: true
			- 在 C++ 中，可以使用以下几种方式来确保线程安全
			  collapsed:: true
				- 使用互斥量（mutex）来对共享资源进行保护。互斥量可以用来防止多个线程同时访问共享资源，从而避免数据竞争的问题。
				- 使用读写锁（reader-writer lock）来对共享资源进行保护。读写锁允许多个读线程同时访问共享资源，但是写线程必须独占资源。这样可以在保证线程安全的同时，也尽可能地提高系统的并发性。
				- 使用原子操作来对共享资源进行保护。在 C++ 中，可以使用 std::atomic 类型来定义原子变量，并使用原子操作来对共享资源进行操作。这样可以确保在多线程环境中，原子变量的操作是安全的。
				- 使用条件变量（condition variable）来协调线程间的协作。条件变量可以用来在线程之间传递信号，从而控制线程的执行流程。
				- 使用线程本地存储（thread-local storage）来保存线程的私有数据。线程本地存储可以用来给每个线程分配独立的存储空间，从而避免数据冲突的问题。
			- C++中的锁有哪几类
				- [C++线程中的几类锁 - 掘金 (juejin.cn)](https://juejin.cn/post/7094191714667069447)
				  collapsed:: true
					- 互斥锁
						- **互斥锁用于控制多个线程对它们之间共享资源互斥访问的一个信号量**
					- 条件锁
						- **条件锁就是所谓的条件变量，当某一个线程因为某个条件未满足时可以使用条件变量使该程序处于阻塞状态，一旦条件满足则以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。**
						- 最为常见的就是在线程池中，初始情况下因为没有任务使得任务队列为空，此时线程池中的线程因为“任务队列为空”这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒该线程来处理这个任务。
					- 自旋锁
						- 自旋锁与互斥锁的区别是: 互斥锁不会导致线程死等, 而自旋锁会.
							- 线程因访问互斥锁而被阻塞时, 会被放入等待队列中, 会导致不会死等
							- 线程因访问自旋锁而被阻塞时, 会导致处理器死等, 直到等到想要的资源;
					- 读写锁
						- 允许多个读, 但只允许一个写
					- 递归锁
						- 递归锁，也称为嵌套锁，是一种可以被同一线程多次获取的锁。C++中的std::recursive_mutex就是一个例子。其与普通锁最大的区别就在于，如果一个线程已经对一个递归锁进行了锁定，那么这个线程可以再次调用lock()进行锁定，只要每次调用lock()，都对应调用一次unlock()进行解锁，这个线程就不会被阻塞。
						- 来看一个生活中的例子。比如一段道路只能通过一辆车，我们把这条道路看做是一个资源，车看作线程。如果没有递归锁，那么当一辆车正在通过这条路时，即使是自己，也不能再次经过这条路，必须等道路完全空闲才能再次通过（比如车子需要兜个大圈子再过）。这就像普通的互斥锁。
						- 但是如果有了递归锁，就好比这条路可以识别通过的车辆，当识别到已经通过的车辆再次请求时，就可以允许这辆车通过。这样一辆车可以多次通过这样的路，只要最后都离开就行，比如车子在途中需要暂时掉头返回等。希望这个例子可以帮助你理解递归锁。
		- 智能锁，项目里用到了吗
		- 面向对象三大特性
		  collapsed:: true
			- 抽象
			- 封装
			  collapsed:: true
				- 封装就是将数据和方法组合在一个类中, 只向外提供可供访问的接口
				  collapsed:: true
					- 封装的主要目的是隐藏类的内部实现细节，仅暴露必要的接口给外部。
				- 从而提高项目的结构性和安全性
			- 继承
			  collapsed:: true
				- 继承是一个类（派生类，Derived Class）从另一个类（基类，Base Class）那里获得其属性和方法的过程。
				- 继承主要是为了提高代码复用性和可维护性。
			- 多态
			  collapsed:: true
				- 一个函数名对应多种方法
				- 分类
					- 静态多态 (在编译过程中确定要调用的方法)
						- 函数重载
						- 运算符重载
					- 动态多态 (在程序执行过程中才能确定调用的方法)
						- 虚函数
							- 根据指针指向的对象的类型, 确定要调用的方法
		- 讲讲多态
		- 虚函数，原理
		  collapsed:: true
			- 虚函数表：每个包含虚函数的类都会有一张虚函数表（Virtual Table），其中存储着该类中所有虚函数的地址。
			  collapsed:: true
				- 虚函数表是一个由指针构成的数组，每个指针指向一个虚函数的实现代码。
			- 虚函数指针：在通过这个类实例化对象的时候, 会分配给对象一个虚表指针（Virtual Table Pointer，简称 VTable 指针）。这个指针指向该对象对应的虚函数表，从而让程序能够动态地调用正确的虚函数。
			- 当一个基类指针或引用调用虚函数时，我们就可以使用对象的虚表指针来查找该对象对应的虚函数表，并根据函数在虚函数表中的位置来调用正确的虚函数。
		- ==静态成员函数可以是虚函数吗==
		  collapsed:: true
			- 首先什么是[static](https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020)静态成员函数？静态成员函数不属于类中的任何一个对象和实例，属于类共有的一个函数。也就是说，它不能用this指针来访问，因为this指针指向的是每一个对象和实例。
			- 对于[virtual](https://so.csdn.net/so/search?q=virtual&spm=1001.2101.3001.7020)虚函数，它的调用恰恰使用this指针。在有虚函数的类实例中，this指针调用vptr指针，指向的是vtable(虚函数列表)，通过虚函数列表找到需要调用的虚函数的地址。总体来说虚函数的调用关系是：this指针->vptr(4字节）->vtable ->virtual虚函数。
			- 所以说，static静态函数没有this指针，也就无法找到[虚函数](https://so.csdn.net/so/search?q=%E8%99%9A%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020)了。所以静态成员函数不能是虚函数。他们的关键区别就是this指针。
		- 内联函数
		  collapsed:: true
			- 在编译时，编译器会把每个调用内联函数的地方替换为实际的函数体。
			- 内联的目的是为了减少函数的调用开销，从而提高运行效率，但会增加代码体量。
		- 内联函数可以是虚函数吗
		  collapsed:: true
			- 严格来说, 如果希望通过虚函数实现多态, 就不能内联
			- 因为内联函数在编译时就进行了展开, 虚函数实现多态, 是在程序运行过程中决定具体调用哪个虚函数
		- 构造函数和析构函数可以是虚函数吗
		  collapsed:: true
			- ==原则: 只要有虚表指针, 就可以是虚函数==
			- **构造函数不可以是虚函数**
				- 因为虚函数需要通过初始化好之后的对象的虚表指针, 找到该对象所属的类对应的虚函数表
				- 但是只有执行过构造函数, 对象才会拥有虚表指针. 所以构造函数不可以是虚函数
			- **析构函数可以且常常是虚函数**
				- 若析构函数是虚函数，delete 时，基类和子类都会被释放；若析构函数不是虚函数，delete 时，只有基类会被释放，而子类没有释放，存在内存泄漏的隐患。
		- 纯虚函数和抽象类
		  collapsed:: true
			- 纯虚函数是没有函数体的虚函数，它的存在只是为了告诉派生类说你们要去实现这些函数
			- 带有纯虚函数的类称为抽象类。抽象类不能实例化对象, 它的作用是去派生出其它类
		- vector和deque的区别，线程安全吗
		  collapsed:: true
			- [C++三种容器：list、vector和deque的区别_c++ list可以存对象指针么-CSDN博客](https://blog.csdn.net/gogokongyin/article/details/51178378)
				- vector是连续存储结构, 支持随机访问, 可在尾端高效地增删元素, 可动态扩容
				- deque是连续存储结构, deque除了具有vector的所有功能外， 还支持高效的首/尾端插入/删除操作。
				- list是双向链表, 非连续存储结构, 增删很方便, 但不支持随机访问
			- C++ STL容器线程不安全
				- 以vector为例，写线程如果触发动态扩容会导致读线程的迭代器失效
				- 解决方法: 在开始并发读写之前（比如初始化）的时候，给vector设置好大小, 避免动态扩容
				  collapsed:: true
					- ```c++
					  struct Data {
					  ...
					  };
					  vector<Data> v;
					  v.resize(1000);
					  ```
				-
		- 迭代器的作用
		  collapsed:: true
			- 迭代器可以帮助我们在不了解容器内部原理的情况下遍历容器。
			- 迭代器是容器和算法的粘结剂，只要容器提供迭代器的接口，同一套算法代码可以利用在完全不同的容器中
	- ### Go
	  collapsed:: true
		- [Go协程的的通讯有哪些方式？](https://top.interviewguide.cn/issue/457)
	- ### 操作系统
	  collapsed:: true
		- 进程和线程
			- 什么是进程?
			  collapsed:: true
				- 进程就是运行着的程序实例
				- 进程由程序段, 数据段, PCB 组成
				  collapsed:: true
					- PCB包含什么
						- pid (进程ID)
						- PC (程序计数器)
						- 通用寄存器
						  collapsed:: true
							- 页表始址寄存器
							- 程序状态字寄存器
								- 程序状态寄存器PSW是计算机系统的核心部件——运算器的一部分，PSW用来存放两类信息：一类是体现当前指令执行结果的各种状态信息，称为状态标志，如有无借位进位（CY位）、有无溢出（OF位）、结果正负（SF位）、结果是否为零（ZF位）、奇偶标志位（PF位）等；另一类是存放控制信息，称为控制状态，如允许中断(IF位)，跟踪标志（TF位），方向标志(DF)等。有些机器中将PSW称为标志寄存器FR（Flag Register）。 [1]
						- 进程状态
						- 进程优先级
				- 进程是资源分配的基本单位
			- 什么是线程?
			  collapsed:: true
				- 线程可以看做一种"轻量级进程"
				- 线程只包含一些在运行中必不可少的资源, 如 tid(线程ID), PC(程序计数器), 内核栈, 通用寄存器 组成,
				  collapsed:: true
					- (每个线程有自己的栈, 每个进程有自己的堆)
				- 线程是CPU调度的基本单位
			- 进程和线程的区别
			  collapsed:: true
				- 一个进程可能包含多个线程;
				  每个进程有自己独立的资源,
				  同一进程的线程共享资源
					- 进程是资源分配的基本单位; 线程是CPU调度的基本单位
					- 因为每个进程都有自己独立的资源空间, 所以进程要着重处理进程间通信问题
					- 因为同进程的线程共享资源, 所以它们很容易通信, 但与此同时, 也涉及到多线程并发时对资源的互斥访问问题, 所以对于线程要着重处理线程间的同步和互斥问题
					- 线程间切换开销小
						- 因为进程切换时, 需要切换地址空间, 或者说切换页表
						- 线程切换只需要切换tid, PC, 内核栈和一些通用寄存器的值
			- #### 协程
				- 创建和切换协程的开销比线程小很多。因为协程由程序员自己管理,不需要操作系统内核的干预。
				- 协程是由当前程序主动控制的,可以随意挂起和恢复,这种灵活性使得代码更容易编写和理解。而线程的切换则由操作系统内核完成,程序员没有太多控制权。
				- 协程是单线程执行的,不会真正发生并行,因此不需要处理线程安全问题。这使得协程编程模型更简单。
				- 协程适用于I/O密集型的场景,比如网络编程、爬虫等。因为在等待I/O操作完成时,可以切换到其他协程继续工作,从而提高资源利用率。
		- 进程间通信的方式
		  id:: 66077df7-e19c-4723-a8d2-99b4d12afcf1
			- 管道
			  collapsed:: true
				- **管道就是内核里面的一串缓存** (管道是特殊的文件，只存在于内存，不存于文件系统中)
				- 只有写进程和读进程同时就绪, 才能开始进行信息传输 (怪不得叫管道; 想像A要把嘴里的水喂给B, 那么必须A和B的嘴都叼住吸管才行; 也就是说管道本身不能作为一个暂存区)
				- 其它
				  collapsed:: true
					- 写进程写满之后, 读进程才能读; 读进程读空之后, 写进程才能写
					- 只支持半双工通信
			- 消息队列
			  collapsed:: true
				- **消息队列实际上是保存在内核中的消息链表**
				- 消息队列可以作为一个暂存区, 写进程写完就走, 读进程需要时再读.
				- 仍有用户态与内核态之间的数据拷贝开销
				- 其它
				  collapsed:: true
					- ~~(带查证) 消息队列, A进程不用等到B进程读完数据再返回, 通信效率比管道高~~
					  collapsed:: true
						- 管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。
						- 对于这个问题，**消息队列**的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。
					- 缺点
						- **消息队列不适合比较大数据的传输**
						  collapsed:: true
							- 因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义  `MSGMAX`  和  `MSGMNB` ，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。
						- **用户态与内核态之间的数据拷贝开销**
						  collapsed:: true
							- 因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。
			- 共享内存
			  collapsed:: true
				- **共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存空间中**
				- 多进程对共享资源的互斥访问问题
			- 信号量
			  collapsed:: true
				- 用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。
				- **信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据**。
					- 同步是指控制进程执行的先后顺序
			- 信号
			  collapsed:: true
				- 上面说的进程间通信，都是常规状态下的工作模式。**对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。**
				- Ctrl + C 终止进程就是一种信号
				- 信号是进程间通信机制中**唯一的异步通信机制**，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。
					- **1.执行默认操作**。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。
					- **2.捕捉信号**。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。
					- **3.忽略信号**。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即  `SIGKILL`  和  `SEGSTOP` ，它们用于在任何时候中断或结束某一进程。
			- Socket
				- 前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想**跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。**
				- Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。
				- ![image.png](../assets/image_1711684192211_0.png){:width 200}
		- 线程间的通信方式
		  id:: 66077df9-95ee-42f8-8102-37ba201ef933
		  collapsed:: true
			- 同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题
			- 信号量也同样可以在线程间实现互斥与同步：
				- 互斥的方式，可保证任意时刻只有一个线程访问共享资源；
				- 同步的方式，可保证线程 A 应在线程 B 之前执行；
		- 死锁
		  collapsed:: true
			- 定义
			  collapsed:: true
				- 比如A和B两个进程都需要1和2两个资源, A占用了1, 需要请求2; 但2被B占用, B需要继续请求1
				- A和B都需要1和2两个资源才能继续向下推进, 但是它们都保持着已经占有的资源不放手, 造成了一种循环等待的僵局, 这就是死锁
			- 原因
			  collapsed:: true
				- 竞争资源
				- 进程推进顺序非法
			- 产生死锁的4个必要条件
			  collapsed:: true
				- 资源是互斥资源
				  collapsed:: true
					- 一个资源同一时刻只能被一个进程访问
				- 进程已有资源不可剥夺
				  collapsed:: true
					- 只能进程在用完后主动释放
				- 保持并请求
				- 循环等待
			- 解决方法
			  collapsed:: true
				- 预防
				  collapsed:: true
					- 破坏掉4个条件之1, 在程序运行之前就能保证程序没有死锁的可能
						- 破坏不剥夺
						- 破坏"保持并请求"
						  collapsed:: true
							- 要么分配全部资源, 要么就不分配
						- 破坏"循环等待"
						  collapsed:: true
							- 给资源按类别编号, 一个进程按照编号从小到大的顺序依次申请资源 (申请完编号为i的资源以后, 只能再申请编号大于i的资源)
				- 避免
				  collapsed:: true
					- 银行家算法
					  collapsed:: true
						- 主要思想
							- 如果假设将资源分配出去之后, 可以找到一个安全序列, 推进完所有进程, 则进行分配; 否则不进行分配
						- 具体过程
						  collapsed:: true
							- 银行家算法, 在资源动态分配过程中, 防止系统进入不安全状态
							- 当Request <= Need && Request <= Available时
							- 先将资源分配出去, 然后执行安全性算法, 判断将资源分配出去以后, 系统是否是安全状态(即能否找到一个安全序列); 若是, 那这样就行了; 但若不是, 就要把分出去的资源回收起来
				- 检测与解除
				  collapsed:: true
					- 死锁定理
						- 在==资源分配图==中, 不断将资源请求都可以得到满足的进程的边消去. 若最终可以消去所有边, 说明不会死锁; 若不能, 说明死锁了
					- 解除方法
						- 进程回退法
							- 回退某些死锁进程 (此时进程主动释放资源, 而非被剥夺)
						- 资源剥夺法
							- 挂起某些死锁进程
						- 撤销进程法
							- 撤销某些死锁进程
		- Cache
		  collapsed:: true
			- 定义
				- cache就是高速缓存, 相当于主存的副本小柜子, 存放着当前频繁访问到的内存块
				- 根据程序的局部性原理, 我们最终可以得到速度接近Cache, 但容量接近主存的效果
			- 目的
				- Cache主要是为了缓解CPU和主存速度不匹配的问题; (因为Cache离CPU近, 更追求速度)
			- 一般用存取速度较快的SRAM制成
		- 虚拟存储器
		  collapsed:: true
			- 定义
				- 虚拟内存就是: 让应用程序认为它拥有一个连续完整的地址空间，但实际上物理内存块可能是离散存储的，还有部分暂时存储在外存上，在需要时才会换入内存。
			- ~~具体~~
			  collapsed:: true
				- 程序执行时, 我们不需要把整个程序调入内存, 只需要将目前用得到的一小部分物理块调入内存, 就可以启动我们的程序, 之后再用到内存中没有的物理块时, 再将其从外存调入内存即可
				- 根据程序的局部性原理, 我们最终可以得到存取速度接近内存, 但是存储空间接近外存的虚拟存储器
			- ~~目的~~
			  collapsed:: true
				- 虚存主要是解决内存容量不足的问题; (因为这个存储体系离外存近, 更追求空间)
		- 虚存工作过程
		  collapsed:: true
			- 用户按照虚地址, 也就是逻辑地址进行编程, 所以要将逻辑地址转变为内存物理地址
			- 先将逻辑地址划分为页号和页内偏移, 再通过页表将页号转化为页框号, 页框号+页内偏移就得到我们要访问的页所在的主存物理地址;
			- 而有时, 页表发现我们要访问的页号没有对应的页框号, 这说明我们要访问的物理块还没有调入到内存中,  那我们就触发"缺页中断", 找到当前要访问的页相应的物理块(页表中会记录页号和物理块号的映射关系; 物理块号就是页框号), 调入内存即可; 如果系统分配给当前进程的驻留集已满, 还要执行页面置换算法
		- Cache和虚存的异同
		  collapsed:: true
			- 同
				- 它们都采用了副本小柜子机制, 就是会有一个速度较快但空间较小的存储器, 和一个速度较慢但空间较大的存储器;
				  根据程序的局部性原理, 最终可以得到空间较大速度较快价格较低的存储器
			- 异
				- 目的
					- Cache主要目的是缓解CPU和主存速度不匹配的问题;
					- 虚存主要是解决内存空间不足的问题
				- 实现
					- Cache完全由硬件进行管理, 对系统程序员和应用程序员都透明;
					- 主存-辅存体系是由硬件和软件共同实现的, 对系统程序员不透明, 但对应用程序员透明
						- 为什么说虚存的实现需要软件? 这里的软件就是指操作系统, 比如缺页中断就需要软件的帮助
		- 进程调度算法
		- 页面置换算法
		- 磁盘调度算法
		- 用户态和内核态
		  collapsed:: true
			- 用户态（User Mode）：运行用户程序
			  内核态（Kernel Mode）：运行操作系统程序，操作硬件
			- ![image.png](../assets/image_1711871751997_0.png){:width 400,:height 800}
		- Linux的一些命令操作
		  collapsed:: true
			- [Linux 常用命令学习 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/linux-common-command-2.html)
		-
		- [线程与进程的比较或者说区别？](https://top.interviewguide.cn/issue/163)
		- [进程、线程和协程的区别和联系](https://top.interviewguide.cn/issue/162)
		- [Linux和windows下的进程通信方法和线程通信方法分别有哪些？](https://top.interviewguide.cn/issue/178)
		- [在并发编程时，在需要加锁时，不加锁会有什么问题？](https://top.interviewguide.cn/issue/451)
		- [说说你了解的死锁？包括死锁产生原因、必要条件、处理方法、死锁回复以及死锁预防等（死锁相关问题大总结，超全！）](https://top.interviewguide.cn/issue/303)
		- [Linux中异常和中断的区别/键盘敲击发生的中断是怎么回事？](https://top.interviewguide.cn/issue/218)
		- [用户态和内核态是什么？有什么区别？](https://top.interviewguide.cn/issue/607)
		- [介绍一下几种典型的锁](https://top.interviewguide.cn/issue/142)
		- [堆和栈的区别](https://top.interviewguide.cn/issue/15)
	- 其它
	  collapsed:: true
		- C/C++ , python, java
			- 使用场景
				- C/C++适用于==对性能要求较高==、==需要直接访问硬件==或者进行底层编程的项目，比如操作系统、驱动程序、嵌入式系统等。
					- 编译型; 需要通过编译器将源代码转换为二进制的可执行文件。
				- python是一种解释型编程语言, 简洁易读, 库也丰富. 适用于数据分析、人工智能等领域
					- 解释型; 不需要显式的编译步骤，解释器会逐行读取源代码并执行相应的操作。
				- Java是一种面向对象的编程语言, 具有平台无关性和强大的类库支持. 适用于开发企业级后端系统, Android应用等
					- Java源代码首先被编译成字节码文件（.class文件），然后由Java虚拟机（JVM）解释执行。
		- [如何设计一个高性能/高并发/高可用/高可靠/可扩展的系统?](https://top.interviewguide.cn/issue/736)
-
- ## 前沿
  collapsed:: true
	- ### 编码
	  collapsed:: true
		- 点云编码
		  collapsed:: true
			- [MPEG Point Cloud Compression – The public information on MPEG Point Cloud Compression (mpeg-pcc.org)](https://mpeg-pcc.org/)
			  collapsed:: true
				- **How does AR/VR/MR work?**
					- To create a 3D scene, volumetric visual data is used to describe the geometry of the scene and the objects it includes, and attributes such as color, opacity, etc. Temporal information is described by individual capture instances (think frames in 2D), or other means (position of an object as a function of time e.g.).
				- **What is Point Cloud Compression?**
				  collapsed:: true
					- Volumetric visual data is typically computer-generated or is captured from the real world. Point cloud is a common representation format for this data, the other being polygonal mesh (多边形网格). ==Point Cloud Compression (PCC) is thus the way of compressing volumetric visual data.==
					- A point cloud is a set of individual 3D points, each point having a ==3D position== but also being able to contain some other attributes such as ==color, surface normal==, etc. Point clouds are more flexible than polygonal mesh when representing ==non-manifold geometry== and could be ==processed in real-time==.
					  collapsed:: true
						- non-manifold geometry
							- 在计算机图形学和几何建模中，non-manifold geometry（非流形几何）是指具有不符合流形性质的几何结构。在三维几何模型中，流形是指具有连续、平滑和无孔洞的拓扑结构。换句话说，流形几何是由完整的、连续的表面组成的。
							- 非流形几何包含了一些不符合这些要求的特征，比如空洞、边缘不连续、自相交等。这些特征使得模型的拓扑结构变得复杂，不容易用传统的多边形网格表示。
							- 在给定的上下文中，当提到点云能够表示非流形几何时，意味着点云数据可以包含那些具有不连续、不平滑或具有孔洞的几何特征。点云数据通过存储每个点的三维位置以及其他属性（如颜色、表面法线等），可以灵活地表示这些复杂的几何结构。
							- 相比之下，多边形网格在表示非流形几何时可能会遇到一些困难，因为它们通常要求拓扑结构是连续的，表面是封闭的，并且没有孔洞。而点云作为一种较为灵活的数据表示形式，可以更好地处理非流形几何，并且能够在实时处理中使用。
					- 3D point cloud data can be applied to many fields, such as cultural heritage, immersive videos, navigation, etc. Due to the wide range of applications, the MPEG PCC standardization activity had to generate **three categories of point cloud test data:**
						- static (many details, millions to billions of points, colors),
						- dynamic (less point locations, with temporal information) and
						- dynamically acquired ( millions to billions of points, colors, surface normal and reflectance properties attributes).
					- The standard we are currently developing is a point cloud comprising a list of 3 points coordinate (x, y, z) along with reflectance and RGB attributes associated with each point.
						- 三维空间坐标
						- 颜色 (RGB)
						- 反射率
				- **What is MPEG?**
					- MPEG, short for Moving Picture Experts Group, is one of the main standardization groups dealing with multimedia. Its goal is to build an open standard for compactly representing 3D point clouds.
				- **Short story**
					- In 2014, the MPEG 3D Graphics Coding group (3DG) started to study how to adapt their tools to advanced immersive applications. However, the standards developed by the 3DG were made for computer animated content, which usually deals with sparse geometric content and a limited amount of noise, whereas in real-time systems, point clouds are dense and noise can’t be ignored. Consequently, these standards were not suited for the situation, hence the need to find other standards.
					- A call for proposals (CfP), developed in close cooperation with stakeholders (major mobile devices manufacturers, leading startups, etc.), was published in January 2017.
					- After the results, three different technologies were chosen as test models for the three different categories targeted:
						- LIDAR point cloud compression (L-PCC) for dynamically acquired data
						- Surface point cloud compression for (S-PCC) for static point cloud data
						- Video-based point cloud compression (V-PCC) for dynamic content
					- ==The final standard is to be published early 2020 and will consist in two classes of solutions.==
						- **Video-based, equivalent to V-PCC**, appropriate for point sets with a relatively uniform distribution of points.
						- **Geometry-based (G-PCC)**, equivalent to the combination of L-PCC and S-PCC, appropriate for more sparse distributions.
			- Introduction to the G-PCC standard
				- trivial
				  collapsed:: true
					- The MPEG committee (ISO/IEC JTC 1/SC 29/WG 7) is developing the MPEG-I standard for encoding, encapsulation, and delivery of immersive media. Part 9 of this standard, Geometry-based Point Cloud Compression (G-PCC), provides a standard for coded representation of the point cloud media.
					- Point cloud may be created in various manners. Recently, 3D sensors such as Light Detection And Ranging (LiDAR) or Time of Flight (ToF) devices are widely used to scan dynamic 3D scenes.
					  To precisely describe 3D objects or real-world scenes, point clouds come with a large set of points in 3D space with geometry information and attribute information. The geometry information represents the 3D coordinates of each point in the point cloud; the attribute information describes the characteristics (e.g., color and reflectance) of each point. Point cloud requires a large amount of data, bringing huge challenges to data storage and transmission.
					  MPEG 3D Graphics Coding group (3DG) announced the Call for Proposal on point cloud compression in January 2017[1]. This project targets delivering efficient compression technologies for different types of point clouds that are acquired with different methods. 
					  According to the contributions from industry and academia, the standardization activities progressed to two distinct technical solutions: V-PCC (ISO/IEC 23090 Part 5) which is suitable for coding dense content; and G-PCC (ISO/IEC 23090 Part 9) which is efficient for relatively sparse data. A detailed history of the early standard development process can be found in [2].
				- G-PCC encodes the geometry and attribute information of a point cloud separately. The geometry information is coded first while the attribute compression depends on the reconstructed geometry. The codec architectures of the encoder and decoder are illustrated in Figure 2 covers the major components in the standard.
				- ![image.png](../assets/image_1710816267833_0.png){:width 666}
				- Regarding the geometry, two coding tools are provided, Octree and Predtree (Predictive tree). The Octree coding provides general compression method while the Predtree coding intends to provide low-delay applications.
				- There are 3 attribute coding methods in G-PCC: Region Adaptive Hierarchical Transform (RAHT) coding, interpolation-based hierarchical nearest-neighbour prediction (Predicting Transform), and interpolation-based hierarchical nearest-neighbour prediction with an update/lifting step (Lifting Transform).  
				  The detail information of the coding tools can be found in [2].
		- 视频编码
		  collapsed:: true
			- H.264
			  collapsed:: true
				- [最通俗易懂的H264基本原理-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1608800)
				  collapsed:: true
					- H264压缩技术主要采用了以下几种方法对视频数据进行压缩。包括：
						- 帧内预测压缩，解决的是空域数据冗余问题。
						- 帧间预测压缩（运动估计与补偿），解决的是时域数据冗余问题。
						- 整数离散余弦变换（DCT），将空间上的相关性变为频域上无关的数据然后进行量化。
						- CABAC压缩。
				- lgt
					- ![image.png](../assets/image_1711444585565_0.png){:width 567}
					- ![image.png](../assets/image_1711444590549_0.png){:width 567}
					- 前向编码
						- 空间: 划分宏块 (16x16)
						- 时间: 帧分组 (GOP, I帧, P帧, B帧)
						- 选取一个待编码宏块 $F_n$
						- 选择进行帧间预测还是帧内预测, 得到预测值 $P$
						  collapsed:: true
							- 帧间预测 (解决时间域的冗余问题)
								- ME (运动估计)
									- 运动估计(ME)的过程其实就是计算运动向量MV的过程：
										- 寻找当前待编码块在已编码图像中的最佳对应快，并计算出偏移量：运动向量
								- MC (运动补偿)
									- 利用运动矢量和某种帧间预测的方法，从而估计出当前块的像素值的过程。
							- 帧内预测 (解决空间域的冗余问题)
							  collapsed:: true
								- 帧内预测利用当前帧已编码的块的像素的来预测当前待编码块的像素值。
								- 色度和亮度信息是被分开预测
								- ![image.png](../assets/image_1711444079414_0.png){:width 567}
								-
						- $F_n - P$ 得到残差 $D_n$
						- 对残差 $D_n$ 进行变换和量化, 得到 $X$
						  collapsed:: true
							- 变换
							  collapsed:: true
								- 变换编码（Transform Coding）是将空间域描述的图像，经过某种变换形成变换域中的数据，这种变换通常是正交变换
								  collapsed:: true
									- 正交变换不会改变信源的熵值，变换之后图像的信息量并没有损失，完全可以通过反变换得到原来的图像值。
								- 正交变换不会损失信息, 但是可以改变数据的分布，将数据集中分布之后就可以使用进一步的量化操作来去除大部分的0值和接近0的值。
								- 正交变换中的理论最优变换是K-L变换, 实际中常用的正交变换有 DCT变换，DFT变换(离散傅里叶变换)，Hadamard变换。
								- 因为DCT系数主要集中在低频区域，越是高频区域系数值越小，通过设置不同的视觉阈值的量化电平，将许多能量较小的高频系数量化为0，可以增加变换系数中0的个数，同时保留能量较大的系数分量，对量化之后的系数进行熵编码可以获得进一步的压缩。
							- 量化
							  collapsed:: true
								- 量化的思想很简单, 就是用一个数表示一组数.
								- 量化是一个不可逆的过程，因为它引入了数据损失。这就是有损压缩的意义所在：为几个值选择一个代表。
								- ![image.png](../assets/image_1711444888389_0.png){width: 444}
						- 重排序
						  collapsed:: true
							- 参考帧重排的意义：由于在解码每个（P/B）MB时，都要用到参考帧的索引ref_idx_l0或ref_idx_l1。假如有个参考帧（短期参考帧或者长期参考帧）对于解码一个图像特别有用，但是这个参考帧在缺省的队列中并不位于索引值为0的位置，所以编码大的索引值需要花费多的比特。参考帧的重排序可以使这个参考帧位于索引值比较小的位置，以节省编码比特数。
						- 熵编码
						  collapsed:: true
							- 类似于哈夫曼编码; 给高频数据短码，给低频数据长码。
							- 熵编码即编码过程中按熵原理不丢失任何信息的无损编码方式，也是有损编码中的一个关键模块，处于[编码器](https://so.csdn.net/so/search?q=%E7%BC%96%E7%A0%81%E5%99%A8&spm=1001.2101.3001.7020)的末端。信息熵为信源的平均信息量（不确定性的度量）。常见的熵编码有：**香农(Shannon)编码、哈夫曼(Huffman)编码，指数哥伦布编码(Exp-Golomb)和算术编码(arithmetic coding)**。由于熵编码编码的是编码器通过量化、变换、运动、预测等一系列操作之后得到的需要编码的符号，根据编码符号的分布情况选择适合的熵编码模型，因此熵编码是一个相对独立的单元，可以不止适用于视频编[解码](https://so.csdn.net/so/search?q=%E8%A7%A3%E7%A0%81&spm=1001.2101.3001.7020)，在其他编码器，如图像编码、点云编码中同样适用
					- 反向重建
						- 编码器的重建流程的目的是为了确保编码端和解码端使用一致的参考帧来生成预测宏块P
						- 逆量化
						- 逆变换
						- 去块效应滤波器
			- H.265
			  collapsed:: true
				- 基本: 以更低的比特率提供更高的视频质量
				- [HEVC – What are CTU, CU, CTB, CB, PB, and TB? | CODE: Sequoia (wordpress.com)](https://codesequoia.wordpress.com/2012/10/28/hevc-ctu-cu-ctb-cb-pb-and-tb/)
				- 首先是针对编码的各个环节都引入各自对应的单元
					- CTU & CU
					  collapsed:: true
						- 与H264中宏块类似的是，在 H.265里面用的是一系列互不重叠的==编码树单元CTU==处理信息，CTU内部可以以四叉树结构递归向下划分成更小的正方形编码单元CU。CU可以支持最大64x64的尺寸，因而可以对高分辨率视频中的平坦和复杂区域做有针对性的CTU划分。
							- ==CB是进行图间预测还是图内预测的决策点。更准确地说，预测类型是用CU(编码单元)编码的。CU由三个CBs (Y、Cb和Cr)和相关的语法元素组成。==
					- PU
					  collapsed:: true
						- 预测单元PU是定义在CU上的一个矩形区域，用来存储和预测相关的所有信息如帧内预测方向、帧间预测的参考帧、和MV等。
							- CB对于预测类型决策足够好，但对于存储运动向量(帧间预测)或帧内预测模式来说，它仍然可能太大。例如，一个非常小的物体，比如降雪，可能会在8×8 CB的中间移动——我们希望根据CB的部分使用不同的mv。
							- 于是，引入了PB。根据时间和/或空间的可预测性，每个CB可以不同地划分为PBs。
					- TU
					  collapsed:: true
						- 变换单元TU是变换和量化的基本单位，支持4种正方形的尺寸大小(4/8/16/32)。变换时采用RQT技术，基于四叉树结构进行自适应变换。大块的 TU 模式能够将能量更好地集中，小块的 TU 模式能够保存更多的图像细节。根据当前 CU 内残差特性，自适应选择变换块大小，可以在能量集中和细节保留两者做最优的折中。与传统的固定块大小变换相比，RQT 对编码效率贡献更大。
							- 一旦做出预测，我们需要用类似dct的变换来编码残差(预测图像与实际图像之间的差异)。同样，CB可能太大，因为CB可能同时包含详细部分(高频)和平坦部分(低频)。因此，每个CB可以被不同地分割成tb (Transform Block)。注意，TB不一定要与PB一致。对来自多个PBs的残差执行单个变换是可能的，而且通常是有意义的，反之亦然。
					- CU划分成PU和TU，PU和TU之间存在交叉重叠关系，Inter预测时允许CU内的TU跨越PU边界，Intra预测时，TU不能跨越PU边界。
				- 其它
					- H265把变换和量化模块结合了起来，降低了计算复杂度，支持加权量化矩阵。
					- 在帧内预测模块，H265支持更多的帧内预测模式。H265的亮度分量支持35种帧内预测模式包括平面模式、DC模式和33种角度模式，色度分量有5种帧内预测模式包括平面模式、DC模式、水平、垂直方向模式和对应于亮度分量的帧内预测模式。
			- H.266
			  collapsed:: true
				- 整体的框架不变, 但是对每个环节都有一些改进; 比如块划分, 帧内预测, 帧间预测, 变换和量化, 熵编码
		- MPEG/AVS
		- slurm
		- FFmpeg
		- 熟悉音视频容器（flv，mkv，mp4，wmv，avi,rm/rmvb等）的封装格式；
		- 熟悉HLS 、Http、HttpLive、rtp/rtsp中一种以上流媒体开发；
		- 熟悉Dolby Vision、Dolby Audio、DTS Audio、CTS、GTS等认证相关工作优先；
	- ### DASH
	  collapsed:: true
		- 定义
		  collapsed:: true
			- 全称为 Dynamic Adaptive Streaming over HTTP; 所以DASH是基于HTTP的, 因此在传输层是基于TCP的, 这与webrtc不同
		- 过程
		  collapsed:: true
			- 在服务器上进行准备工作:
			  collapsed:: true
				- 切segment
					- 一个完整的视频被切分为多个segment/chunk，包含几秒的视频内容（通常2～5s，时长相等）。
				- 多版本
					- 在DASH中，一个视频会被编码为多个不同的质量等级（称为Representation），通常对应不同的分辨率（如480p、720p、1080p）和平均码率（如1.85Mbps、2.85Mbps、4.3Mbps）。
				- MPD
					- DASH使用MPD (**Media Presentation Description**) 文件来描述视频信息。(每种质量等级的每个segment的存储url)
					- 格式
						- Periods: 一段时间的视频 (11min56s)
						- Adaptation Sets: 音频流和视频流
						- Representation: 多种质量版本
						- Segment: 多个视频块
			- stream过程
			  collapsed:: true
				- 客户端首先请求并解析MPD文件，获取服务器上的视频信息。
				- 客户端通过ABR算法决定所请求视频块的质量等级，每次使用HTTP GET请求一个视频块，并使用播放器进行播放。
		- ==ABR算法==
		  collapsed:: true
			- [[ABRRulesCollection]]
			  collapsed:: true
				- 整体架构图: ((62ee34a7-5cce-4c41-a532-edff3d9c762f))
					- MPD parser
					- Schedule Controller
					- ABR Controller
					- Fragment Loader
					- Buffer Controller
				- 主要规则
					- 基于吞吐量
					  id:: 660bdf6b-5311-4228-8e22-14d417469dd5
					  collapsed:: true
						- 预测吞吐量 (历史吞吐量通过之前的segment大小除以下载时间计算出来)
						- 选择低于吞吐量90%的bitrate level
					- 基于缓冲区
					  collapsed:: true
						- 将缓冲区存量映射到比特率等级; 一般直接使用阶梯函数
					- 动态切换
					  collapsed:: true
						- motivation
						  collapsed:: true
							- 缓冲区不足或为空时, 基于吞吐量的方法效果更好;
							- 缓冲区充足时, 基于缓冲区的方法效果更好
						- method
							- startup: 基于吞吐量
							- 缓冲区存量大于10s, 且基于缓冲区的方法所选择的bitrate更大, 则切换至基于缓冲区的方法
							- 缓冲区存量小于10s, 且基于吞吐量的方法所选择的bitrate更大, 则切换至基于吞吐量的方法
				- 次要规则
					- 缓冲区不足
					  id:: 660bdf7f-a624-4555-9dad-c159cb7ee9b7
					  collapsed:: true
						- 估计出吞吐量, 乘以0.7, 得到安全吞吐量
						- 使用安全吞吐量 乘 缓冲区存量, 得到在缓冲区耗尽之前能够下载的数据量
						- 使用这个数据量除以segment duration, 就得到了所允许的最大bitrate
					- 比特率等级震荡
					  collapsed:: true
						- 比如bitrate level从3下降至2, 那么未来8个segment都不能切换至3及3以上的bitrate level
					- 设备CPU算力不足导致丢帧
					  collapsed:: true
						- 如果用户设备对于当前 bitrate level 的视频的丢帧率超过15%, 那么就下调bitrate level; 哪怕网络情况允许更高的bitrate
				- 其它
					- 打断
					  collapsed:: true
						- 本来预测着网络状况很好, 选择下载高bitrate level的segment; 结果在下载过程中, 发现网络状况突然恶化, 我们可以放弃高bitrate level的segment的下载, 转而下载低bitrate level
					- 替换
					  id:: 660bdfc0-9aaa-4c46-b9ee-6ab503d823c4
					  collapsed:: true
						- FAST SWITCHING使用以下步骤
							- 决定是下载一个新的segment还是替换旧的segment
								- 使用ABR方法决策出当前下载的bitrate level b
								- If there is segment in the buffer **with a bitrate lower than b** ==and== if such a segment **can be safely replaced**, then FAST SWITCHING decides that the next segment downloaded will be a replacement.
								- Otherwise, the next segment downloaded will be a new segment that is appended to the end of the buffer.
								- FAST SWITCHING considers any segment that is within 1.5×(the segment length) of the play head to be not safely replaceable.
								  collapsed:: true
									- The choice of 1.5×(the segment length) in defining a safe replacement gives a 50% safety factor to account for possible variations in the download time due to network and/or segment size variability.
									- [[#blue]]==这里应该考虑当前的带宽去估计replace segment的下载时间啊 <-- 其实不用想得这么复杂, 既然当前可以去下载bitrate为b的segment, 就不太可能需要高于 1.5×(the segment length) 的时间才下载完成==
			- [[Low latency streaming]]
			  collapsed:: true
				- 基础策略
					- [[CMAF]] + [[CTE]] (把segment进一步切分成更小的chunks)
				- 关键挑战
					- 对吞吐量的预测 (对于下载时长的计算)
						- 由于CMAF和CTE, 一个segment在下载各个chunks的过程中会存在空闲时间, 所以我们不能单纯将一个segment从下载开始到下载结束的时间作为它的下载时长, 而是应该剔除掉其中的空闲时间
					- 变速机制
						- 将实际延迟稳定在目标延迟附近; 如果实际延迟高于目标延迟, 应适当加快视频播放速度; 如果实际延迟低于目标延迟, 应适当减慢视频的播放速度; 延迟太低也是不好的, 因为我们需要有一段缓冲区来避免卡顿
						  collapsed:: true
							- 具体的速度调控公式为 $\frac{1}{1+e^{-x}}$ (其实就是Sigmoid函数)
						- LoL+的变速方法除了考虑目标延迟, 还考虑缓冲区
						  collapsed:: true
							- 优先判断当前缓冲区存量是否小于我们所允许的最小阈值; 若是, 则减慢视频的播放速度, 直到缓冲区存量大于最小阈值
								- 使用 $\frac{1}{1+e^{-x}}$ 缩短缓冲区存量和最小阈值之间的差距, 直到缓冲区存量不再低于最小阈值
							- 缓冲区存量大于最小阈值的情况下, 才会考虑使实际延迟接近目标延迟
								- 也是使用 $\frac{1}{1+e^{-x}}$
				- 常用算法
					- [[LoL+]]
					- [[L2A]]
				-
		- rtsp
			- [Differences between RTSP, RTCP, and RTP (huawei.com)](https://forum.huawei.com/enterprise/en/Differences-between-RTSP-RTCP-and-RTP/thread/667276296662695936-667213857636102144)
				- RTSP (Real-Time Streaming Protocol) (实时流协议)、RTCP(实时传输控制协议)和RTP(实时传输协议)是用于在互联网上流式传输多媒体内容的三种协议。
					- RTSP是一种控制协议，用于发起、终止和控制流会话。它还用于协商流参数，如媒体类型、编码格式和比特率。
					- RTCP是一种反馈协议，用于监控流会话的服务质量(QoS)。提供丢包率、时延和抖动等信息。
					- RTP是一种传输协议，用于传输流媒体数据。它提供了时间同步和序列编号等功能。
				- RTSP、RTCP和RTP通常一起用于在internet上流式传输多媒体内容。RTSP用于发起和控制流会话，RTCP用于监控流会话的QoS, RTP用于发送流媒体数据。
				- 下面是RTSP, RTCP和RTP如何一起使用来通过互联网流式传输视频的示例:
					- 发送方通过向接收方发送RTSP请求来发起流会话。
					- 接收端响应一个RTSP响应，确认流会话的启动并协商流参数。
					- 发送端开始向接收端发送RTP报文。
					- 接收端接收RTP报文并显示视频。
					- 接收端向发送端发送RTCP报文，提供流会话的QoS反馈。
					- 如果有必要，发送方根据接收方的反馈调整流参数。
				- RTSP、RTCP和RTP是在因特网上传输多媒体内容的基本协议。它们提供了以可靠和高效的方式启动、控制、监视和交付流媒体数据所需的功能。
			- [手撕RTSP协议系列（1）——Rtsp基本流程-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1711409)
				- ![image.png](../assets/image_1711803110200_0.png){:width 400,:height 800}
				- **OPTIONS**
					- 客户端向服务器发送OPTIONS请求, 获取服务器能提供的请求选项
					  collapsed:: true
						- An OPTIONS request returns the request types the server will accept.
					- ![image.png](../assets/image_1711803696953_0.png){:width 400,:height 800}
				- **DESCRIBE**
					- DESCRIBE请求可以使客户端获得一些媒体信息的描述, 比如编码格式, 比特率, 视频长度等. 使用sdp文件的格式发过来.
				- **SETUP**
					- 客户端向服务器端发起建立连接请求，请求建立==会话连接==
					- 客户端告诉服务器自己用于接收RTP数据的端口和接收RTCP数据的端口;
					  服务器告诉客户端自己用于发送RTP数据的端口和接收RTCP数据的端口;
				- **PLAY**
					- 客户端向服务端请求播放媒体。
					- 发送端开始向接收端发送RTP报文。
					- 接收端接收RTP报文并显示视频。
					- 接收端向发送端发送RTCP报文，提供流会话的QoS反馈。
					- 如果有必要，发送方根据接收方的反馈调整流参数。
				- **TEARDOWN**
					- 结束播放的时候，客户端向服务器端发起结束请求
					- 服务端收到消息后，向客户端发送 `200 OK`，之后断开连接
				-
	- ### [[WebRTC]]
	- ### [[QUIC]]
-
- ## 算法
  collapsed:: true
	- [==146. LRU 缓存 - 力扣（LeetCode）==](https://leetcode.cn/problems/lru-cache/description/)
	- [合并两个有序链表](https://top.interviewguide.cn/issue/479)
	- [==136. 只出现一次的数字 - 力扣（LeetCode）==](https://leetcode.cn/problems/single-number/)
	- [==111. 二叉树的最小深度 - 力扣（LeetCode）==](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)
	- [==56. 合并区间 - 力扣（LeetCode）==](https://leetcode.cn/problems/merge-intervals/description/)
	- [==33. 搜索旋转排序数组 - 力扣（LeetCode）==](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/)
	- [==53. 最大子数组和 - 力扣（LeetCode）==](https://leetcode.cn/problems/maximum-subarray/description/)
	  collapsed:: true
		- 题目要我们找出和最大的==连续子数组==的值是多少，「连续」是关键字，连续很重要，不是子序列。
		- 题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用==「动态规划」==解决。
	- [==46. 全排列 - 力扣（LeetCode）==](https://leetcode.cn/problems/permutations/)
	- [==692. 前K个高频单词 - 力扣（LeetCode）==](https://leetcode.cn/problems/top-k-frequent-words/description/)
	  collapsed:: true
		- 字典排序只会对键值做排序! 如果想完整地对字典进行排序, 参考
			- [如何按值对 Python 字典进行排序 (freecodecamp.org)](https://www.freecodecamp.org/chinese/news/sort-dictionary-by-value-in-python/)
	- [==5. 最长回文子串 - 力扣（LeetCode）==](https://leetcode.cn/problems/longest-palindromic-substring/)
	- [==143. 重排链表 - 力扣（LeetCode）==](https://leetcode.cn/problems/reorder-list/description/)
	-
	- [==7. 整数反转 - 力扣（LeetCode）==](https://leetcode.cn/problems/reverse-integer/)
	-
-
- ## MMSys
  collapsed:: true
	- Adaptive Video Streaming
		- 360°视频: [[@BOLA360: Near-optimal View and Bitrate Adaptation for 360-degree Video Streaming]]
		  collapsed:: true
			- 360°视频场景, 相比于普通2d视频场景, ABR决策时不仅需要考虑带宽, 还需要考虑视点位置
			- BOLA360每次会针对一个chunk制定下载策略. 具体来说, 会将Buffer Level映射到一个bitrate level, 然后根据当前chunk中各个tiles被view的概率, 分配每个tile的bitrate等级
		- 体积视频 (点云): [[@QV4: QoE-based Viewpoint-Aware V-PCC-encoded Volumetric Video Streaming]]
		- VR云游戏: [[@FovOptix: Human Vision-Compatible Video Encoding and Adaptive Streaming in VR Cloud Gaming]]
		- 普通视频: [[@Low-Latency Live Video Streaming over a Low-Earth-Orbit Satellite Network with DASH]]
	-
	- 视频会议应用中交互性的QoE metrics
	  collapsed:: true
		- 交互性主要受到用户之间媒体传输延迟的影响，而媒体传输延迟又是网络延迟和应用程序处理延迟的函数。
		- 首先，我们提出了一套有意义的可量化交互性指标，如沉默时间的比例和重叠语音的比率，这些指标可以反映交流障碍, 因此可以用来建模QoE。
		- ## 3 METRICS
			- ### 3.1 Any Number of Clients
				- Turnaround Time (TT)
				  collapsed:: true
					- TT被定义为从客户端结束发言到他们开始听到响应的时间。
				- Silence Time Ratio (STR)
				  collapsed:: true
					- 静默时间 = sum of TT + 尴尬的沉默
					  collapsed:: true
						- 沉默时间比率描述了在没有任何客户说话的情况下所花费的总会话时间的比例。由于回合更改通常是静默的，静默时间的下限是由conversation time规范化的周转时间之和。由于周转时间取决于延迟，较高的延迟意味着在静默状态下花费的时间更多。额外的STR可能来自谈话中的自然中断或其他事件，如“尴尬的沉默”。STR的定义如下:
				- Overlap Time Ratio (OTR)
				  collapsed:: true
					- The ability of VCA clients to partake in turn-taking depends on their ability to detect the presence of other clients’ speech. Latency between clients will hinder the ability to do this in a timely manner, increasing the risk of speaking out of turn, therefore resulting in multiple clients speaking at once. Overlap time ratio (OTR) describes the percentage of total conversation with more than one client talking. In a typical conversation, the scenario of multiple people talking simultaneously causes inefficient communication, as no useful information can be exchanged, and thus OTR can be understood as a measure of the wasted time in a conversation. The definition of OTR is similar to STR:
				- Overlap Rate (OR)
				  collapsed:: true
					- In a typical conversation, repairing overlapping speech may require an action from the participants to reset the current turn. Prior work [54, 55] suggests that overlaps are generally short in duration (a few syllables), and regardless of duration, they result in the same type of repair. As a result, measuring the overlap rate (OR) gives insight into how often this scenario arises during the conversation. OR is defined as:
				- Useful Conversation Time Ratio (UCTR).
				-
			-
-
- ## HR面
  collapsed:: true
	- 你有什么优点?
	  collapsed:: true
		- 硕士期间的研究方向和部门的业务方向匹配度较高
		- 踏实认真
		  id:: 661bcb36-aba4-4e08-919a-b1ca4a49fac8
		  collapsed:: true
			- 我个人的性格是学一个东西做一件事, 一定要把它学透, 做好, 所以本科时花了很多很多时间进行专业课的学习, 专业排名始终维持在年级前5, 但是因为我那一届的保研政策变了, 德育分占比较高且没有上限, 我加上德育分之后的综合排名能降到30多, 所以错失了保研机会.
			- 当时我很多同学就也是觉得很不合理, 挺为我可惜的, 但我自己就感觉还好, 因为我知道凭借自己的积累和努力, 通过考研也可以考上一个比较理想的院校.
			- 之后我也确实通过自己的努力, 也考上了北京邮电大学的计算机专业, 而且进入了一个国家重点实验室, 这也算是对我踏实认真的性格特点和学习能力的证明
		- 有计划性和条理性
		  collapsed:: true
			- 我习惯每天列一个计划清单, 并享受把任务完成的成就感
			- 计划性体现在, 我总会提前计划好一天要完成的任务, 制定出一份时间表, 有计划地去完成.
			  collapsed:: true
				- 番茄钟
			- 条理性体现在, 不管是在学习中还是生活中, 我都习惯将一件事归纳成条理清晰的程序: 比如准备考研的时候, 我很喜欢给一类题归纳出自己的解题步骤, 那是让我很享受的过程, 因为我在自己创造知识;  当时学蛙泳的时候, 我最后也整理出蛙泳的步骤.
			  collapsed:: true
				- 考研
					- 自创求字符串next数组的S花边法
				- 蛙泳
					- 分, 抱, 夹; 换气
					- 伸手, 低头, 收翻
					- 蹬夹
		- 性格乐观开朗, 爱好广泛
		  collapsed:: true
			- 我积极参加各种活动, 比如中国消化内镜学年会的志愿者, 一二九合唱比赛和运动会, 等等.
			- 我兴趣广泛，利用业余时间学习过口琴、声乐和乒乓球，这成为我学习之余很好的放松方式。
	- 你有什么缺点?
	  collapsed:: true
		- 经验不足
		  collapsed:: true
			- 因为是第一次找实习; 但我也一定会因此更加踏实努力, 尽快融入团队和具体的工作中, 积累各方面的经验
		- 太过谨慎
		  collapsed:: true
			- 总想着把一件事完全想明白计划好再去做, 但这就往往导致效率很低, 甚至错过很多机会
			  collapsed:: true
				- 其实我感觉这是一种比较典型的学生思维, 可能和应试教育这种培养体系有关
			- 就比如说这次MMSys的比赛, 如果不是师兄告诉我可以参加, 我自己可能就想不到参加, 可能就会觉得自己之前也从来没做过, 能做好吗, 能拿名次嘛之类的事.
			- 但是这次比赛能拿到第一名给了我很大的鼓励和信心, 我之后会多去勇敢尝试
			- trivial
			  collapsed:: true
				- 60分比100分更重要, 也就是说, 完成比完美更重要, 更科学的方式应该是先完成, 然后不断优化迭代.
		- trivial
		  collapsed:: true
			- 平时不爱打理自己
			  collapsed:: true
				- 打理自己没有什么意义, 毕竟就长这个样了
				- 自己也不太在乎自己的外在形象
			- 节奏比较慢.  但我会有自己的计划, 会在计划时间内完成任务; 只是我好像需要更多的时间, 去将接收到的知识压缩成自己的格式, 存储在大脑里.  但我觉的我也会理解得更透彻一些.
			  collapsed:: true
				- 比如在高中的时候, 那时候老师每天都布置做不完的作业, 我就一直在做题, 没有自己消化吸收的时间, 那时候每天花很多时间去学, 学得也很累, 但最终成绩也还是不理想;  大学的时候我就可以自己安排自己的学习节奏, 包括准备考研的时候, 我做的卷子其实很少, 但我会按照自己的学习计划, 把学过的所有内容吃透, 所以最终也取得了不错的成绩
			- 想不到去尝试和了解新东西
			  collapsed:: true
				- 总想着把一件事完全想明白, 计划好, 才去做, 这其实会导致我错失很多机会. 比如本科的时候, 我就感觉把专业课学好是第一要务, 一些加德育分的活动就参加得很少, 对保研政策也没有了解清楚. 包括这次ACM MMSys的比赛, 也是师兄告诉我可以参加, 我才参加的
				- 要多了解信息, 敢于尝试. 我目前在自己每天的计划清单上会加一条: 了解业界最新进展
	- 你父母或者老师朋友对你的评价是什么？
	  collapsed:: true
		- 认真负责 (老师)
		  collapsed:: true
			- 当时给老师做助教的时候, 老师有偷夸过我是所有助教里做的最好的, 我也不知道她是不是对每个助教都这么说, 但当时还挺开心的; 因为我确实对老师交给我的每个任务都会用心去对待, 尽力做到最好
		- 开朗随和, 乐于助人 (朋友)
		  collapsed:: true
			- ((662cfa18-5057-4119-bdec-0ac83341c775))
		- trivial
		  collapsed:: true
			- 我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。另外他们也会觉得我很随和，与不同的人都可以友好相处, 总是能站在别人的角度考虑问题。）
	- 如果与同事发生了意见的不一致，你会如何解决呢? 举个例子
	  collapsed:: true
		- **理解观点**：首先，我会倾听对方的观点，从对方的角度理解问题。只这样才能意识到我们之间的分歧点以及可能的解决方案。
		- **提出观点**：然后，我会尽可能清晰地阐述我自己的观点，尽量结合事实和数据
		- **开展讨论**：讨论的目标是寻找解决问题的最佳方法，而不是争论谁是对的。
		  collapsed:: true
			- 我相信通过开放、坦诚的讨论，我们可以找到一个双方都可以接受的解决方案。在讨论的过程中，我会保持开放和尊重的态度
		- **寻求第三方观点**：如果我们无法达成一致，我可能会寻求一个中立的第三方为我们提供意见。这个第三方可以是我们的上一级领导, 或者是其它相关的决策者。
		- **达成协议**：无论最后的决定是什么，关键是我们都需要尊重并接受这个决定。我们的目标是做出对公司最有利的决策，而不是坚持我们自己的观点。
		- 例子
			- 和师兄一起改GC论文
	- 如果与同事发生矛盾, 你会如何解决呢? 举个例子
	  collapsed:: true
		- 反思是不是自己的问题, 如果是要道歉
		- 双方都冷静下来之后, 一定要沟通交流, 多站在对方的角度考虑问题. 其实大多数矛盾的发生都是因为交流少存在误解导致的. 只要静下心来, 深入交流, 相互理解, 那么99%的矛盾都可以被解决
		- 例子: 借工位
			- 实验室里工位紧张, 需要共用工位, 有学弟来找我借, 我就商量好我上午用8:00-10:00, 下午用16:00-18:00, 其它时间在图书馆
			- 结果发现16:00的时候他还没走, 还在工位上打游戏, 就发生了一些矛盾
			- 自我反省, 静下心来交流, 相互理解, 最终矛盾也解决了, 相处得也很和谐
	- 说说你帮助同事的经历
	  id:: 662cfa18-5057-4119-bdec-0ac83341c775
	  collapsed:: true
		- 比如有一次, 我的一个同学在科研上遇到一些问题, 和我交流之后, 我发现他还是之前的学习思维, 就是自底向上地想把所有的知识都掌握, 这就造成他效率很低. 我就告诉他要目标导向地学习, 根据具体要解决的问题有选择性地学习. 果然他之后的科研就顺利多了, 还得到了老师的表扬
	- 什么样的同事是你无法接受的?
	  collapsed:: true
		- 责任心不强, 不认真对待工作
			- 因为我本身做事是很认真负责的, 如果到时候合作一个项目, 他总是应付, 不认真对待的话, 就还挺难受的
		- 不尊重他人, 不懂得倾听, 自以为是
	- 你觉得从小到大的经历中你成长的最大的那个点是什么？
	  collapsed:: true
		- 读研过程中完成了学习思维的转变
		- 因为像之前高中包括本科阶段的学习, 都是具体告诉你要学什么了, 你学就是了. 你可能不知道学这些知识有什么用, 实际你也确实用不上, 更多就是为了应付考试, 是一个从基础知识学起的自底向上的过程;
		- 但是读研时, 没有人会告诉你要学哪些知识, 甚至你具体要解决哪个问题, 都要自己去寻找, 是一个从最上层问题出发, 自顶向下, 根据你具体想要解决的问题, 去有针对性地选择自己要学习的内容. 所以我的学习思维慢慢转变为目标导向的.
		- 然后我发现这种目标导向的学习才是真正的自驱的学习, 就是你学这些知识, 就是为了解决一个你想解决的具体问题, 就是要干自己想干的某件事情. 包括我这次去意大利参加学术会议, 因为会议上都是使用英语交流嘛, 我就特别希望能够听懂他们在讲什么, 特别希望和他们交流, 就那一刻, 我对于学习英语的动力, 是高中和大学时为了应付考试学英语是不能比的
	- 你觉得从小到大的经历中让你最耿耿于怀的事情是什么？最大的挫折, 最有压力的事, 如何解决的; 最近比较痛苦的事
	  collapsed:: true
		- 高中阶段, 那时候学校和老师会安排好你要做的任务, 会布置很多作业, 做完就十点十一点了, 根本没有时间进行自己的整理和消化. 但其实我在学习方面是高度自主化的, 我有自己的一套方法, 我不需要做很多题, 而是需要大量时间对少数高质量的题目做整理和吸收. 我考研可以自主规划学习的时候相当于只做了真题就取得了不错的成绩.
		- 高中那段时间就很没有自信, 越没有自信就越不敢脱离学校的教学体系, 就一定非要把老师布置的大量作业做完, 一直没有自己整理消化的时间, 形成恶性循环. 老师家长也只是觉得你不够努力, 没有把所有精力和时间用到学习上, 不了解你真正的困难和问题在哪
		  collapsed:: true
			- 所以高中那段时间我学的特别痛苦. 受当时环境影响也总是用成绩去评定自己,
		- 那段时间就只能熬着. 因为在我高中的时候, 受我自己认知的局限, 受周围人认知的局限, 真的就是没有办法. 但是我认为很重要的一点是: 在你目前处在一个很艰难的阶段的时候, 一定要记住, 并不是你不行, 只是你目前还没有找到适合你的方法. 不要丧失自信, 坚持下去, 熬下去, 多反思, 最终一定可以战胜困难.
		- 像前段时间, 比赛参会, 论文投稿, 找实习这三件事同时压过来, 我也是感觉很艰难, 压力很大. 像这种时候我就告诉自己不要烦躁, 把大任务拆分成每天要做的小任务, 按照deadline不断调整它们的优先级, 一天一天按照计划做下去, 总会都完成的. 我目前意大利的学术会议也顺利参加了, 论文也顺利投稿了, 只要专心找实习就可以了, 也算是熬过了一小段艰难的时间.
	- ==你做项目的过程中遇到过最大的困难是什么? 是如何解决的?==
	  collapsed:: true
		- 中移
		  collapsed:: true
			- 当时卡顿预测的精确率就是提不上去, 尝试了各种时间序列预测模型, 以及特征提取的方法, 效果都不太理想.
			- 在和中国移动研究院那边沟通之后, 明确了数据集中同时包含了直播和点播数据, 然后突然想到, 直播的缓冲区较小, 考虑近期的网络情况即可; 而点播的缓冲区较长, 需要考虑较长一段时间的网络情况.
			- 将直播数据和点播数据分开, 采用不同时间窗口大小的预处理, 分别训练模型进行卡顿预测
			- 最终卡顿预测的精确率从70%左右提高到85%左右
		- GC
		  collapsed:: true
			- 在360°视频点播流传输挑战赛中, 我们要实现的ABR策略, 是针对360°视频的点播流传输的, 目前业界并没有合适的参考
			- 在和师兄讨论之后, 我们决定参考目前DASH中针对普通视频比较成熟的ABR策略
			- 首先就要先搞懂DASH中各个ABR策略的原理
			- 然后分析360°视频点播流传输的特点, 其实主要就是除了网络情况还要考虑到视点预测结果
			- 最后选择出适合的
				- 基于缓冲区的主要策略
				- 缓冲区不足和低质量tile的替换策略等次要策略
			- 具体实现
	- 你有什么兴趣爱好
	  collapsed:: true
		- 音乐
			- 声乐
			- 口琴
		- 运动
			- 乒乓球
			- 游泳
			- 健身
			- 搏击
		- 这些都能够帮助我很好地平衡工作和生活, 释放工作中的压力
	- 介绍未来5年职业规划（必考题！！!）
	  collapsed:: true
		- 因为我目前在找实习嘛, 所以我感觉当务之急是找到方向合适的实习, 尽快融入团队和具体工作中, 去积累经验, 提高能力，让自己成为音视频领域的专业人士
		  id:: 661bd255-10f9-4c38-a366-6e9e633ec590
		- 随着我能力和经验的提高, 可以考虑去带领团队，完成更大的项目, 给公司创造更大的价值, 也为公司培养出一匹优秀的新人
		- 多了解音视频领域的最新进展, 因为计算机相关领域, 技术更新迭代特别快, 只有不断学习, 才能不被时代所淘汰
	- 你在生活中追求什么？
	  collapsed:: true
		- 充实感和自我提升
		- 给他人提供帮助和价值
	- 近来个人有什么打算？
	  collapsed:: true
		- ((661bd255-10f9-4c38-a366-6e9e633ec590))
		- 多锻炼身体, 多阅读
	- 请结合这次应聘，谈谈你在选择工作时都考虑哪些因素？
	  collapsed:: true
		- 方向匹配度
		- 行业的发展前景
		- 公司文化和团队氛围
	- 你是怎么看待加班的?
	  collapsed:: true
		- 对于任何一家公司来说，通过加班赶工期和赶进度是很正常的事
		- 自身的工作任务没有完成，加班是理所当然的，当然，自己会不断提高专业技能，提高工作效率, 避免不必要的加班
		- 如果遇到紧急任务或突发情况时，需要加班，这个时候我也会和我们各个团队成员一起努力, 优先保证任务能够按时交付
	- **你期望的薪资是多少**
	  collapsed:: true
		- [如何回答“你的期望薪资是多少？” - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/32698287)
			- 因为我现在是在找实习嘛, 所以我对薪资的要求肯定是不高的
			- 但也正因为这样, 我会更加努力地工作, 提高自己的能力, 我相信在我的持续努力之后，公司会分配给我与我能力相匹配的报酬。这也是对我的一个激励嘛
	- **你是如何学习一项新技术的？**
	  collapsed:: true
		- 视频课: b站上找有没有相关的教学视频, 因为确实有很多高质量的教程; youtube
		- 官方英文文档, Guide, samples
		  collapsed:: true
			- 因为这个一定是说的最详细最清楚的, 看的过程中, 会发现很多看视频课时的疑问都可以得到解答
		- 目标导向性学习, 在实践中学习
		  collapsed:: true
			- 会找一个和这个技术相关的项目去做, 这样效率更高, 学的也更深刻
			- 一定是为了解决一个具体的问题去学习这个技术, 这个技术一定接下来会用到才去学, 切忌盲目学习, 那样效率很低的
	- 希望与怎样的领导共事？
	  collapsed:: true
		- 我其实觉得自己作为一个实习生, 没有向领导提要求的资格. 如果斗胆说一项的话, 我感觉就是对我工作中的错误能够立即指出吧
		  collapsed:: true
			- 第一，尽量不要提及对领导的具体要求，而应该突出自己会认真向领导学习，尽快熟悉和适应工作环境，主动向领导请教，保质保量完成本职工作。
			- 第二，如果有做得不到的地方，会诚恳地向领导请教，可以在哪些地方多多改善。这才是一位职业人作为下属应该秉持的工作态度。
			- Tips：切忌一切围绕工作进行，着重谈论对自己有要求，自身努力的方向，千万不要提及前任领导的缺点。
		- 因为我现在刚开始实习, 无论是工作上还是处事上肯定都还有很多不成熟的地方, 所以如果领导愿意指出我的不足, 我会特别感激, 我其实就害怕我有些地方做的不对或者不好, 领导看到了, 但他不和我说, 他就记在心里. 而且我本身是不害怕批评的, 接受批评之后虚心改正可以让我变得更好
	- 若领导布置了大量的工作，而完成时间又十分有限，为了完成任务，您怎么办？
	  collapsed:: true
		- 把大任务分解成每天要做的小任务, 一天一天地完成; 还可以把任务按照轻重缓急排序, 优先完成最重要最紧急的
		- 另一方面, 短时间完成大量任务一定需要团队合作, 所以协调好各个团队成员的分工也至关重要
		- Tips：实在是过重，以上方法全部用上了都不行，那一定要与领导协商说明，砍掉一些不太重要不太紧急的业务, 或者增派一些人手. 切忌不进行沟通, 把小问题拖成大问题
	- 工作中当你与领导意见不一致时，该如何处理？
	  collapsed:: true
		- 首先要深入思考领导的意见, 站在领导的角度去考虑,
		- 如果经过深入的思考之后, 还是觉得领导的决定存在问题, 我会私下单独和领导讨论,
		- 那我也一定会服从领导的安排, 因为对于一个团队来说, 团结是压倒一切的
	- 你为什么选择淘天? 为什么选择我们部门? 为什么应聘这个岗位？
	  collapsed:: true
		- 淘天
		  collapsed:: true
			- 淘天是阿里旗下很知名的一个集团, 注重用户体验，看重科技创新
			- 我目前面试的音视频技术团队, 它所负责的像淘宝直播, 淘宝短视频这些, 也是淘天集团比较重要的业务
		- 岗位
			- 匹配度高
				- 岗位的具体业务
					- 淘天集团业务技术部的音视频团队 (100多人)
					- 采集, 编解码, 处理增强, 传输, 播放器, 质量评价的全链路的音视频技术栈
					- 淘宝直播, 淘宝短视频
				- 我研究生阶段在做的工作也是和音视频传输相关的
			- 面试官强
				- 淘天的面试官是问项目问的最深刻的, 是真的懂我研究生在做的工作; 其它一些公司的面试官在问项目的时候问不到点上
			- trivial
			  collapsed:: true
				- 所以哪怕在杭州, 和我目前的研究生院校不在一个城市, 我也很愿意过去
	- 目前有其它offer吗?
	  collapsed:: true
		- 目前还没有. 现在主要是两家, 快手在等约HR面, 美团在等二面
		  collapsed:: true
			- 快手就比较奇怪; 当时我投了策略算法工程师, 好像跟我之前在做的传输方向有些关系; 但之后HR打电话给我说让我改成投音视频编解码算法工程师, 然后说其实投这个也是各个方向都有, 什么编解码, 传输之类的, 但面试的时候感觉当时二面面试官也不是很懂传输这一块
			- 美团是一个音视频工程师的转正实习, 但是方向上感觉跟我不是很符合, 他们是做客户端播放器开发的
		- 因为我之前一直在忙比赛, 参加学术会议, 论文投稿, 所以简历投晚了, 找实习上就比较耽搁
		- 而且另外两家公司和我的方向不是特别匹配. 淘天这边是我感觉最匹配的, 面试官问的问题也是最深刻的, 让我更够感觉到我们部门是真的懂我在研究生阶段所研究的东西的
	- 面过其它大厂吗，结果怎样
	  collapsed:: true
		- 直接说有，技术面都过了，在排序，不知道结果
	- 还有什么要问的吗？
	  collapsed:: true
		- 如果我之后有幸收到offer的话，公司是否会有系统的入职培训之类的
		- 入职培训的话主要是学习哪些技术或者知识呢？我想提前了解和准备一下
		  collapsed:: true
			- 我希望能够尽早准备一些, 到时候可以更快的融入团队和具体工作
		- 当前岗位的职业发展通道
		-
		- 团队的一些技术栈和所承担的业务
		- 如果通过了未来的工作主要是做什么？
		-
		- 贵公司业务及战略的未来发展？
		- 团队、公司现在面临的最大挑战是什么？
	-
	- 为什么不读研
	  collapsed:: true
		- 音视频这个方向没什么好论的, 本身就是偏实践的学科
		- 做科研的过程中我总有种不够踏实的感觉. 它需要你去找好看的创新点, 讲好听的故事, 在面对一个大领域的时候, 对各个方向其实都来不及了解细节原理, 而我个人更适合踏踏实实地掌握技术的底层细节原理, 这让我更有成就感
		- 所以我感觉相比于科研人员, 我更适合当一名工程师
	- 比较佩服的人
	  collapsed:: true
		- 王敬宇
			- 不论是在科研上, 还是和项目合作的人交际上, 还是和我们这些研究生交流上, 都让我佩服
				- 科研
				  collapsed:: true
					- 他当时指导我论文的时候, 告诉我, 不能只说用了多模态, 用了Transformer, 最后性能提升了, 而是
					- 面对一个很新的领域, 他很快就能听到核心点, 提出的问题总是能够直击要害
				- 和我交流起来感觉完全没有代沟, 心态非常年轻
	- 杂活怎么办
	  collapsed:: true
		- 组织安排的都是有用的，没有杂活一说，能学到东西不算杂活
		- 我去实习不知是为了提升自己能力的, 而是为公司创造价值, 公司根据我所创造的价值给我相应的报酬, 我认为是这样一个关系. 我认为就算是端茶倒水也是为公司服务, 也能学到很多东西
	- 社会和大学的区别？
	  collapsed:: true
		- 独立性
		- 责任感
		- 实际操作
	- 能为我们公司带来什么呢？你工作经验欠缺，如何能胜任这项工作？
	  collapsed:: true
		- 我觉得我目前最大的价值就是给公司注入一股新鲜的血液, 给公司带来年轻的活力与动力. 我有冲劲, 吃苦肯干
		- 我目前刚开始找实习, 经验不足确实是我的一大劣势. 但是也正因为这一点, 我会更加努力, 希望融入团队和具体工作中, 积累经验, 提高能力. 我对我的学习能力是有信心的, 我相信经过一小段时间的适应, 就可以上手工作
	- 谈谈你对跳槽的看法？
	  collapsed:: true
		- 频繁的跳槽对单位和个人双方都不利，应该反对。
			- 个人没有一个踏实的积累; 公司刚花时间和资源把你培养起来你就走了
		- 正常的“跳槽”能促进人才合理流动，应该支持。
		- 至少要干个三四年才不算频繁吧我感觉
	- 自己坚持最久的事是什么
	  collapsed:: true
		- 体育锻炼
			- 从小打乒乓球
			- 游泳
			- 搏击
			- 最近刚开始接触健身
	- 最近读过的一本书
	  collapsed:: true
		- 是李开复和陈秋帆合著的AI.2041, 这本书就展望了受AI发展的影响, 20年之后的人类社会会是什么样
		- 给我印象比较深的是其中一个叫做"双雀"的故事. 这个故事就想象了像chatgpt这种大语言模型应用到教育领域, 每个孩子都有一个强大的AI伙伴之后, 会对孩子带来什么影响, 给社会带来什么影响
		- 其实是重点讲述了对两个孩子的影响. 这两个孩子是双胞胎, 但是性格迥然不同.
			- 金雀开朗外向, 渴望外界的关注, 喜欢竞争, 但也活着外界的评价体系中. AI助手的强大其实加剧了内卷, 当金雀发现自己花了一个月时间用心做出的投资报告被AI几秒钟生成的投资报告完败时, 他开始感觉这种竞争和比赛是没有意义的, 在很多方面他再努力也比不上AI. 所以他开始更多地和各种企业家, 工程师等真实的人接触与交流, 而不是困在单一的竞争中
			- 银雀有自闭症, 和外界的沟通存在障碍, 他更多会向自己的内在世界进行探索. 当时银雀养父的一个心理活动让我挺有感触的. 因为每个孩子的AI伙伴是高度定制化个性化的, 它不仅会影响孩子, 孩子反过来也会塑造它. 银雀的AI伙伴可能受银雀认知模式的影响, 开始打破以强化竞争为导向的反馈循环, 开始转向向内在自我的探索.
			- 因为AI不断地训练迭代, 都是为了把一个外在的损失函数值去降到最小, 去满足一个外在的要求和标准, 在大语言模型训练过程中, 也是训练到说话越来越接近人类, 而不是一个向内在自我探索的过程
			- 人类永远无法创造出真正的强人工智能, 因为人类无法真正定义和判断强人工智能. 人类只能通过表象对强智能进行判断 (如图灵测试). 每个人都被锁在名为自我的牢笼里, 只能通过自己的主观意识认知世界, 而无法定义真正的真实和客观. 我们只能判断自己具有自我意识, 而无法判断其他任何人或者智能体是否具有自我意识, 也无法向外界证明我们自己有自我意识; 甚至存在一种可能, 那就是连我们自己所感受到的自我意识都只是一种幻觉
	-
	- trivial
	  collapsed:: true
		- 说说看，假如你是部门技术经理，线上商户数据丢失怎么办
		  collapsed:: true
			- 如果我是部门技术经理，遇到线上商户数据丢失的情况，首先不要恐慌，按照下面的步骤处理：
			- **立即启用应急预案**：每个公司应该有备份和恢复策略，为这种可能性做好准备。标准程序包括隔离受影响的系统以避免进一步的数据损失，并立即启动备份以恢复丢失的数据。
			- **尝试恢复数据**：根据备份和恢复策略，有经验的工程师应立即尝试恢复数据。这可能涉及从备份文件中寻找并恢复丢失的数据，或者尝试修复导致数据丢失的硬件或软件故障。
			- **分析原因**：一旦系统回复正常运行，进行后续的事故分析。识别导致数据丢失的原因，是由于人为错误，硬件故障，黑客入侵还是其他因素，这对于预防将来的数据丢失事件至关重要。
			- **和商户沟通**：如果必要，我们可能需要向受影响的商户公开这一情况。这需要以透明但负责任的方式行事，解释发生了什么，我们如何处理，以及我们将如何防止类似事件在将来再次发生。
			- 总的来说，数据丢失的情况是非常严重的，要做好的打算和预防以便在突发情况现场能进行有效的处理。
		- 你朋友对你的评价？
		  collapsed:: true
			- 我的朋友都说我是一个负责的, 值得信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。
			- 我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。
		- 如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？
		  collapsed:: true
			- 一段时间发现工作不适合我，有两种情况：
				- 如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；
				- 你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。
		- 在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？
		  collapsed:: true
			- 原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。
			- 如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。
			- 还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。
		- 如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？
		  collapsed:: true
			- 我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。
			- 分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。
			- 总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。
		- 如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？
		  collapsed:: true
			- 我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：
				- 我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。
				- 他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。
		- 工作中你难以和同事、上司相处，你该怎么办？
		  collapsed:: true
			- 如果自己与领导和大部分同事都感觉难以相处, 那大概率是我自己的问题. 我会首先反省自己, 是不是自己的工作上能力不能让领导满意, 某些行为让同事看不惯
			- 如果我自己找不到原因的话，我会找机会跟他们沟通，请他们指出我的不足，有问题就及时改正
		- 假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？
		  collapsed:: true
			- 成绩比较突出，得到领导的肯定, 这说明我的能力得到了领导的认可, 是件好事情，以后更加努力。
			- 但另一方面也要检讨一下自己, 是不是只顾工作缺乏了和同事之间的社交, 因为真正关系好的同时肯定会因为我工作上的成果为我开心
		- 请说出你选择这份工作的动机？
		  collapsed:: true
			- 和目前实际的业界接轨. 因为我这个方向本身纠偏应用, 读研过程中, 我其实深刻的感觉到, 去业界能够学到更多
		- 你能为我们公司带来什么呢？
		-
		- 请告诉我您最近遇到的一次挑战是什么，您是如何应对的？
		  collapsed:: true
			- 又要搞GC去参会, 又要找实习, 又要转投论文
		- 您在过去的工作中，最喜欢做的事情是什么？最不喜欢做的事情又是什么？
		- 您认为自己最擅长的技能是什么？请举例说明。
		- 您是如何处理与同事之间的冲突的？请分享一次具体的经历。
		- 您最近一次与团队合作完成的一个重要项目是什么？您在其中扮演了什么样的角色？
		  collapsed:: true
			- MMSys GC
		- 说下您最近失败的一件事是什么，您有没有做过分析失败的原因是什么，有复盘过吗？
		  collapsed:: true
			- 找实习找晚了; 缺乏沟通
	-
-
- ---
-
- ## Timeline
  collapsed:: true
	- 研二寒假阶段 (1月 - 2月底)
		- 沉淀自己
		  id:: 65a60715-5cff-4f63-882b-07923c7d9926
			- 算法
			- 八股
			- 项目
	- 研二下阶段 (3月 - 6月)
		- 日常实习
			-
		- 暑期实习
			- 3月份其实就要投了
	- 研二升研三暑假 (7月 - 8月)
		- 找到暑期实习
			- 在哪实习不重要, 重要的是在实习时做了什么, 要有自己的思考和收获
			- 实习过程中, 多找项目的亮点和难点; 不是自己写的没关系, 关键是弄懂会讲
		- 没找到暑期实习
			- ((65a60715-5cff-4f63-882b-07923c7d9926))
-
- ## 注意点
  collapsed:: true
	- 多面试
-
- ## 简历
  collapsed:: true
	- ![image.png](../assets/image_1709474394667_0.png){:width 777}
	- ![image.png](../assets/image_1709519521873_0.png){:width 759, :height 424}
	- ### 包含内容
	  collapsed:: true
		- **个人信息**
			- 基本信息
			- 照片
			- 教育经历 (GPA, 专业排名)
		- **履历信息**
			- 实习, 项目, 科研
			- 切忌内容堆砌不聚焦
			- 切忌描述空洞无量化
			- 先概括项目目标, 然后进行具体的分点描述; 在描述中注意数据支撑, 以结果为导向
		- **补充信息**
			- 获奖, 竞赛, 毕设, 课题项目
			- 内驱力, 学习能力, 团队合作, 钻研精神
	- ### 注意点
		- 明确岗位意向 (放在开篇)
		- 精致简历内容
		- 简历命名: 姓名, 应聘岗位, 联系方式
-